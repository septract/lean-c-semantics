import CToLean.Core

/-!
# Real Core AST Examples from C Programs

This module contains Core IR ASTs generated by Cerberus from actual C programs.
These show what we need to handle for real verification.

## Purpose

The WP calculus in `Theorems/WP.lean` currently handles pure expressions (`Pexpr`).
Real C programs produce effectful expressions (`Expr`) with:
- Continuations for control flow (`Esave`, `Erun`)
- Bounds checking wrappers (`Ebound`)
- Strong sequencing (`Esseq`)
- Stdlib function calls (`conv_loaded_int`, etc.)

This file documents the gap between what we can verify and what real C produces.
-/

namespace CToLean.Test.RealAST

open CToLean.Core

/-! ## Helper constructors -/

/-- Create a symbol -/
def mkSym (id : Nat) (name : String) : Sym :=
  { digest := "", id := id, description := .id name, name := some name }

/-- Create an annotated pure expression (no annotations) -/
def mkAPexpr (e : Pexpr) : APexpr := ⟨[], none, e⟩

/-- Create an annotated expression (no annotations) -/
def mkAExpr (e : Expr) : AExpr := ⟨[], e⟩

/-- Create a pattern binding a symbol -/
def mkPattern (sym : Sym) (ty : BaseType) : APattern :=
  ⟨[], .base (some sym) ty⟩

/-- Create a wildcard pattern -/
def mkWildcard (ty : BaseType) : APattern :=
  ⟨[], .base none ty⟩

/-- Integer type: signed int -/
def signedInt : Ctype := .basic (.integer (.signed .int_))

/-- Base type: loaded integer -/
def loadedInteger : BaseType := .loaded (.integer)

/-! ## AST for: int main(void) { return 42; }

Generated by: ./scripts/cerberus --pp=core tests/minimal/001-return-literal.c

```
proc main (): eff loaded integer :=
  let strong a_506: loaded integer = bound(pure(Specified(42))) in
  run ret_505(conv_loaded_int('signed int', a_506)) ;
  pure(Unit) ;
  save ret_505: loaded integer (a_507: loaded integer:= Specified(0)) in
    pure(a_507)
```

This simple `return 42` involves:
1. `Esseq` (strong sequencing) - let bindings with effect ordering
2. `Ebound` - bounds checking wrapper
3. `Epure` - lifting pure expression to effectful
4. `Erun` / `Esave` - continuation-based control flow for return
5. `PEcall` - stdlib function call (conv_loaded_int)
6. `Vloaded` / `LVspecified` / `OVinteger` - the actual value 42
-/

/-- The integer value 42 as a Core Value -/
def val42 : Value :=
  .loaded (.specified (.integer ⟨42, .none⟩))

/-- The integer value 0 as a Core Value (default return) -/
def val0 : Value :=
  .loaded (.specified (.integer ⟨0, .none⟩))

/-- Symbols used in the AST -/
def sym_a_506 : Sym := mkSym 506 "a_506"
def sym_a_507 : Sym := mkSym 507 "a_507"
def sym_ret_505 : Sym := mkSym 505 "ret_505"
def sym_conv_loaded_int : Sym := mkSym 6 "conv_loaded_int"

/-- The innermost expression: pure(Specified(42)) -/
def inner_pure42 : AExpr :=
  mkAExpr (.pure (mkAPexpr (.val val42)))

/-- Wrapped in bound: bound(pure(Specified(42))) -/
def bounded_pure42 : AExpr :=
  mkAExpr (.bound inner_pure42)

/-- The call to conv_loaded_int('signed int', a_506) -/
def conv_call : APexpr :=
  mkAPexpr (.call (.sym sym_conv_loaded_int) [
    .val (.ctype signedInt),
    .sym sym_a_506
  ])

/-- run ret_505(conv_loaded_int('signed int', a_506)) -/
def run_ret : AExpr :=
  mkAExpr (.run sym_ret_505 [conv_call])

/-- pure(Unit) -/
def pure_unit : AExpr :=
  mkAExpr (.pure (mkAPexpr (.val .unit)))

/-- pure(a_507) - the body of the save -/
def pure_a507 : AExpr :=
  mkAExpr (.pure (mkAPexpr (.sym sym_a_507)))

/-- The save continuation:
    save ret_505: loaded integer (a_507: loaded integer := Specified(0)) in
      pure(a_507)
-/
def save_ret : AExpr :=
  mkAExpr (.save sym_ret_505 loadedInteger
    [(sym_a_507, loadedInteger, mkAPexpr (.val val0))]
    pure_a507)

/-- The outer sequence: pure(Unit) ; save ... -/
def seq_unit_save : AExpr :=
  mkAExpr (.sseq (mkWildcard .unit) pure_unit save_ret)

/-- The middle sequence: run ret_505(...) ; pure(Unit) ; save ... -/
def seq_run_unit_save : AExpr :=
  mkAExpr (.sseq (mkWildcard .unit) run_ret seq_unit_save)

/-- The outermost sequence:
    let strong a_506: loaded integer = bound(pure(Specified(42))) in
    run ret_505(...) ; ...
-/
def return42_body : AExpr :=
  mkAExpr (.sseq (mkPattern sym_a_506 loadedInteger) bounded_pure42 seq_run_unit_save)

/-! ## What We Need to Verify This

To prove `return 42` is UB-free, we need WP rules for:

| Construct | Status | Notes |
|-----------|--------|-------|
| `Expr.pure` | ❌ Need | Lift WP from Pexpr to Expr |
| `Expr.sseq` | ❌ Need | Strong sequencing (like let) |
| `Expr.bound` | ❌ Need | Bounds checking wrapper |
| `Expr.run` | ❌ Need | Continuation jump |
| `Expr.save` | ❌ Need | Continuation definition |
| `Pexpr.call` | ❌ Need | Stdlib function calls |
| `conv_loaded_int` | ❌ Need | Integer conversion semantics |

The current WP calculus handles:
- `Pexpr.val` ✅
- `Pexpr.if_` ✅
- `Pexpr.let_` ✅ (pure let, not Expr.sseq)
- `Pexpr.op` ✅ (partial)
-/

/-! ## Comparison: What We Can Verify vs What C Produces

**We can verify (hand-constructed Pexpr):**
```lean
-- if true then 42 else 0
Pexpr.if_ (.val .true_) (.val val42) (.val val0)
```

**C produces (even for return 42):**
```lean
-- sseq(let a = bound(pure(42)), run ret(conv_loaded_int(signedInt, a)), ...)
return42_body  -- defined above
```

The gap is significant: even trivial C produces effectful expressions with
continuations, bounds checking, and stdlib calls.
-/

end CToLean.Test.RealAST
