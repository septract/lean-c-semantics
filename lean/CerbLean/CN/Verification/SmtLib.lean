/-
  SMT-LIB2 Translation for CN Proof Obligations

  This module translates CN proof obligations to SMT-LIB2 format using
  the lean-smt library infrastructure.

  ## Architecture

  We translate CN's IndexTerm to Smt.Term, then use lean-smt's
  Command infrastructure to build queries.

  For an obligation with assumptions [A1, A2, ...] and constraint C,
  we generate:
  - Declarations for all free symbols
  - Assert (not (=> (and A1 A2 ...) C))
  - check-sat

  If the solver returns "unsat", the obligation is discharged.

  Audited: 2026-01-27 (pragmatic pipeline using lean-smt)
-/

import CerbLean.CN.Types
import CerbLean.CN.Verification.Obligation
import CerbLean.Memory.Layout
import Smt.Translate.Term
import Smt.Translate.Commands
import Smt.Data.Sexp

namespace CerbLean.CN.Verification.SmtLib

open CerbLean.Core (Sym Identifier Loc Ctype Ctype_ IntegerType TagDef)
open CerbLean.CN.Types
open CerbLean.Memory (TypeEnv structOffsets sizeof)
open Smt (Term)
open Smt.Translate (Command)

/-! ## Symbol Name Generation -/

/-- Generate a valid SMT-LIB2 identifier from a Sym -/
def symToSmtName (s : Sym) : String :=
  match s.name with
  | some n => s!"{n}_{s.id}"
  | none => s!"_sym_{s.id}"

/-! ## Pointer Model Preamble

CN encodes pointers as an algebraic datatype in SMT (solver.ml:241-351):
- NULL: the null pointer
- AiA(alloc_id, addr): pointer with allocation ID (Int, VIP mode) and address (BitVec 64)

Five helper functions: ptr_shift, copy_alloc_id, alloc_id_of, bits_to_ptr, addr_of.
These use selector functions (alloc_id, addr) auto-generated by declare-datatype.
-/

/-- SMT-LIB2 preamble declaring the pointer datatype and helper functions.
    Must be emitted before any declarations or assertions in every query.
    Corresponds to: CN_Pointer.declare in solver.ml lines 290-351 -/
def pointerPreamble : String :=
  -- Pointer datatype (solver.ml:290-300)
  "(declare-datatype pointer ((NULL) (AiA (alloc_id Int) (addr (_ BitVec 64)))))\n" ++
  -- ptr_shift: shift pointer by bitvec offset (solver.ml:303-310)
  "(define-fun ptr_shift ((p pointer) (offset (_ BitVec 64)) (null_case pointer)) pointer\n" ++
  "  (ite ((_ is NULL) p) null_case (AiA (alloc_id p) (bvadd (addr p) offset))))\n" ++
  -- copy_alloc_id: copy alloc_id from p onto new_addr (solver.ml:314-321)
  "(define-fun copy_alloc_id ((p pointer) (new_addr (_ BitVec 64)) (null_case pointer)) pointer\n" ++
  "  (ite ((_ is NULL) p) null_case (AiA (alloc_id p) new_addr)))\n" ++
  -- alloc_id_of: extract alloc_id (solver.ml:325-331)
  "(define-fun alloc_id_of ((p pointer) (null_case Int)) Int\n" ++
  "  (ite ((_ is NULL) p) null_case (alloc_id p)))\n" ++
  -- bits_to_ptr: convert BitVec to pointer (solver.ml:335-341)
  "(define-fun bits_to_ptr ((bits (_ BitVec 64)) (aid Int)) pointer\n" ++
  "  (ite (= bits (_ bv0 64)) NULL (AiA aid bits)))\n" ++
  -- addr_of: extract address as BitVec 64 (solver.ml:345-351)
  "(define-fun addr_of ((p pointer)) (_ BitVec 64)\n" ++
  "  (ite ((_ is NULL) p) (_ bv0 64) (addr p)))\n"

/-! ## Type-to-Sort Translation

CN uses actual SMT-LIB BitVec types (`(_ BitVec n)`) with bitvector operations.
We must match this exactly.

Corresponds to: CN's solver.ml translate_bt function
-/

/-- Result of sort translation -/
inductive SortResult where
  | ok (tm : Smt.Term)
  | unsupported (reason : String)
  deriving Inhabited

/-- Convert CN BaseType to SMT-LIB2 sort.
    Matches CN's Solver.translate_bt which uses `SMT.t_bits n` for Bits types.
    Corresponds to: solver.ml line 409: `| Bits (_, n) -> SMT.t_bits n`
    Returns unsupported for types that cannot be represented in SMT. -/
def baseTypeToSort : BaseType → SortResult
  | .bits _ width => .ok (Term.mkApp2 (Term.symbolT "_")
                                  (Term.symbolT "BitVec")
                                  (Term.literalT (toString width)))
  | .integer => .ok (Term.symbolT "Int")
  | .bool => .ok (Term.symbolT "Bool")
  | .real => .ok (Term.symbolT "Real")
  | .loc => .ok (Term.symbolT "pointer")  -- CN pointer algebraic datatype (solver.ml:407)
  | .allocId => .ok (Term.symbolT "Int")  -- VIP mode: allocation IDs as integers (solver.ml:171)
  | .unit => .ok (Term.symbolT "Bool")  -- Unit as Bool (TODO C3: should be empty tuple)
  | .memByte => .ok (Term.symbolT "Int")  -- Memory bytes as integers
  | .struct_ tag =>
    let tagStr := tag.name.getD "?"
    .unsupported s!"struct type {tagStr}"
  | .list elemBt =>
    let elemStr := toString (repr elemBt)
    .unsupported s!"list type (element: {elemStr})"
  | .set elemBt =>
    let elemStr := toString (repr elemBt)
    .unsupported s!"set type (element: {elemStr})"
  | .tuple bts =>
    .unsupported s!"tuple type ({bts.length} elements)"
  | .map keyBt valBt =>
    let keyStr := toString (repr keyBt)
    let valStr := toString (repr valBt)
    .unsupported s!"map type ({keyStr} -> {valStr})"
  | .record fields =>
    .unsupported s!"record type ({fields.length} fields)"
  | .datatype dtTag =>
    let dtName := dtTag.name.getD "?"
    .unsupported s!"datatype {dtName}"
  | .ctype =>
    .unsupported "ctype"
  | .option innerBt =>
    let innerStr := toString (repr innerBt)
    .unsupported s!"option type ({innerStr})"

/-! ## Translation to Smt.Term -/

/-- Result of translation: either success or unsupported construct -/
inductive TranslateResult where
  | ok (tm : Smt.Term)
  | unsupported (reason : String)
  deriving Inhabited

/-! ## BitVec Literal Generation

SMT-LIB2 BitVec literals can be written as:
- `(_ bvN W)` - decimal value N of width W bits
- `#xHHHH` - hexadecimal (width must be multiple of 4)
- `#bBBBB` - binary

CN uses the indexed identifier notation: `(_ bvN W)`.
Corresponds to: simple_smt.ml bv_nat function
-/

/-- Generate a BitVec literal in SMT-LIB format: (_ bvN W)
    For negative numbers, we convert to two's complement representation. -/
def mkBitVecLiteral (width : Nat) (value : Int) : Smt.Term :=
  -- Convert negative numbers to two's complement unsigned representation
  let unsignedVal : Nat :=
    if value < 0 then
      let modulus := Nat.pow 2 width
      (modulus - ((-value).toNat % modulus)) % modulus
    else
      value.toNat % (Nat.pow 2 width)
  Term.mkApp2 (Term.symbolT "_")
              (Term.symbolT s!"bv{unsignedVal}")
              (Term.literalT (toString width))

/-! ## Integer Bounds for Representability -/

/-- Get bit width for an integer base kind -/
def intBaseKindWidthSmt (kind : Core.IntBaseKind) : Nat :=
  match kind with
  | .ichar => 8
  | .short => 16
  | .int_ => 32
  | .long => 64
  | .longLong => 64
  | .intN n => n
  | .intLeastN n => n
  | .intFastN n => n
  | .intmax => 64
  | .intptr => 64

/-- Get bounds for an integer type (lo, hi) where lo <= val < hi for representability -/
def integerTypeBounds (ity : Core.IntegerType) : Option (Int × Int) :=
  match ity with
  | .signed kind =>
    let width := intBaseKindWidthSmt kind
    let half := Int.pow 2 (width - 1)
    some (-half, half)
  | .unsigned kind =>
    let width := intBaseKindWidthSmt kind
    let max := Int.pow 2 width
    some (0, max)
  | .char => some (-128, 128)  -- Assuming signed char
  | .bool => some (0, 2)
  | .size_t => some (0, Int.pow 2 64)
  | .ptrdiff_t => some (-(Int.pow 2 63), Int.pow 2 63)
  | .wchar_t => some (-(Int.pow 2 31), Int.pow 2 31)
  | .wint_t => some (-(Int.pow 2 31), Int.pow 2 31)
  | .ptraddr_t => some (0, Int.pow 2 64)
  | .enum _ => some (-(Int.pow 2 31), Int.pow 2 31)

/-! ## Constant Conversion -/

/-- Convert a Const to Smt.Term.
    For Bits constants, generates proper BitVec literals using indexed notation.
    Corresponds to: CN's handling of Const.Bits in solver.ml -/
def constToTerm : Const → TranslateResult
  | .z n =>
    .ok (Term.literalT (toString n))
  | .bits _sign width n =>
    .ok (mkBitVecLiteral width n)  -- Proper BitVec literal
  | .bool true => .ok (Term.symbolT "true")
  | .bool false => .ok (Term.symbolT "false")
  | .null => .ok (Term.symbolT "NULL")  -- CN_Pointer.con_null (solver.ml:542)
  | .unit => .ok (Term.literalT "0")
  | .q num denom => .ok (Term.mkApp2 (Term.symbolT "/") (Term.literalT (toString num)) (Term.literalT (toString denom)))
  | .allocId id => .ok (Term.literalT (toString id))
  | .pointer p =>  -- CN_Pointer.con_aia (solver.ml:545-547)
    .ok (Term.mkApp2 (Term.symbolT "AiA")
      (Term.literalT (toString p.allocId))
      (mkBitVecLiteral 64 p.addr))
  | .memByte m => .ok (Term.literalT (toString m.value))
  | .ctypeConst _ => .unsupported "ctypeConst in SMT query"
  | .default _ => .unsupported "default value in SMT query"

/-- Check if a base type is a bitvector type -/
def isBitsType : BaseType → Bool
  | .bits _ _ => true
  | _ => false

/-- Check if a base type is signed bits (for bitvector operation dispatch) -/
def isSignedBits : BaseType → Bool
  | .bits .signed _ => true
  | _ => false

/-- Check if a term is an integer literal -/
def isIntLiteral (tm : Smt.Term) : Option Int :=
  match tm with
  | .literalT s =>
    -- Try to parse as integer
    match s.toInt? with
    | some n => some n
    | none => none
  | _ => none

/-- Convert an integer to a BitVec literal for use in comparisons.
    Used when comparing integer constants with BitVec values. -/
def intToBitVecTerm (n : Int) (width : Nat) : Smt.Term :=
  mkBitVecLiteral width n

/-- Convert a UnOp application to Smt.Term.
    Type-aware: dispatches to bitvector operations for Bits types. -/
def unOpToTerm (op : UnOp) (argBt : BaseType) (arg : Smt.Term) : TranslateResult :=
  let useBv := isBitsType argBt
  match op with
  | .not => .ok (Term.appT (Term.symbolT "not") arg)
  | .negate => if useBv then .ok (Term.appT (Term.symbolT "bvneg") arg)
               else .ok (Term.appT (Term.symbolT "-") arg)
  | .bwCompl => if useBv then .ok (Term.appT (Term.symbolT "bvnot") arg)
                else .unsupported "bwCompl requires Bits type"
  | .bwClzNoSMT => .unsupported "bwClzNoSMT"
  | .bwCtzNoSMT => .unsupported "bwCtzNoSMT"
  | .bwFfsNoSMT => .unsupported "bwFfsNoSMT"
  | .bwFlsNoSMT => .unsupported "bwFlsNoSMT"

/-- Convert a BinOp application to Smt.Term.
    Type-aware: dispatches to bitvector operations for Bits types.
    Both operands are expected to have matching types (enforced by Pexpr.lean).
    Corresponds to: CN's solver.ml lines 688-702 for arithmetic, 752-765 for comparisons -/
def binOpToTerm (op : BinOp) (lBt rBt : BaseType) (l r : Smt.Term) : TranslateResult :=
  -- Pointer comparisons: extract addresses and compare as bitvectors
  -- Must be handled before the type consistency check since loc is now an ADT sort.
  -- Corresponds to: solver.ml lines 771-776
  match op with
  | .ltPointer =>
    .ok (Term.mkApp2 (Term.symbolT "bvult")
      (Term.appT (Term.symbolT "addr_of") l)
      (Term.appT (Term.symbolT "addr_of") r))
  | .lePointer =>
    .ok (Term.mkApp2 (Term.symbolT "bvule")
      (Term.appT (Term.symbolT "addr_of") l)
      (Term.appT (Term.symbolT "addr_of") r))
  | _ =>
  -- Type consistency check: both operands should have matching types
  -- If they don't, the type checker has a bug - don't mask it
  if isBitsType lBt != isBitsType rBt then
    .unsupported s!"Type mismatch in binop {repr op}: left={repr lBt}, right={repr rBt}"
  else
  -- Both operands should have matching types after Pexpr type fixup
  -- Use left operand's type to determine if we need bitvector ops
  let useBv := isBitsType lBt
  let signed := isSignedBits lBt  -- Only meaningful when useBv = true
  let mkBinApp (sym : String) := .ok (Term.mkApp2 (Term.symbolT sym) l r)
  match op with
  -- Arithmetic operations
  | .add => if useBv then mkBinApp "bvadd" else mkBinApp "+"
  | .sub => if useBv then mkBinApp "bvsub" else mkBinApp "-"
  | .mul => if useBv then mkBinApp "bvmul" else mkBinApp "*"
  | .mulNoSMT => if useBv then mkBinApp "bvmul" else mkBinApp "*"
  | .div =>
    if useBv then
      if signed then mkBinApp "bvsdiv" else mkBinApp "bvudiv"
    else mkBinApp "div"
  | .divNoSMT =>
    if useBv then
      if signed then mkBinApp "bvsdiv" else mkBinApp "bvudiv"
    else mkBinApp "div"
  | .rem =>
    if useBv then
      if signed then mkBinApp "bvsrem" else mkBinApp "bvurem"
    else mkBinApp "mod"
  | .remNoSMT =>
    if useBv then
      if signed then mkBinApp "bvsrem" else mkBinApp "bvurem"
    else mkBinApp "mod"
  | .mod_ =>
    if useBv then
      if signed then mkBinApp "bvsmod" else mkBinApp "bvurem"
    else mkBinApp "mod"
  | .modNoSMT =>
    if useBv then
      if signed then mkBinApp "bvsmod" else mkBinApp "bvurem"
    else mkBinApp "mod"
  -- Comparison operations
  | .lt =>
    if useBv then
      if signed then mkBinApp "bvslt" else mkBinApp "bvult"
    else mkBinApp "<"
  | .le =>
    if useBv then
      if signed then mkBinApp "bvsle" else mkBinApp "bvule"
    else mkBinApp "<="
  | .eq => mkBinApp "="  -- Equality is the same for all types
  -- Logical operations (type-independent)
  | .and_ => mkBinApp "and"
  | .or_ => mkBinApp "or"
  | .implies => mkBinApp "=>"
  -- Pointer comparisons handled above (before type consistency check)
  | .ltPointer | .lePointer => .unsupported "unreachable: pointer comparisons handled above"
  -- Bitwise operations (require bitvector types)
  | .bwXor => if useBv then mkBinApp "bvxor" else .unsupported "bwXor requires Bits type"
  | .bwAnd => if useBv then mkBinApp "bvand" else .unsupported "bwAnd requires Bits type"
  | .bwOr => if useBv then mkBinApp "bvor" else .unsupported "bwOr requires Bits type"
  | .shiftLeft => if useBv then mkBinApp "bvshl" else .unsupported "shiftLeft requires Bits type"
  | .shiftRight =>
    if useBv then
      if signed then mkBinApp "bvashr" else mkBinApp "bvlshr"
    else .unsupported "shiftRight requires Bits type"
  -- Unsupported operations
  | .exp => .unsupported "exp"
  | .expNoSMT => .unsupported "expNoSMT"
  | .min => .unsupported "min"
  | .max => .unsupported "max"
  | .setUnion => .unsupported "setUnion"
  | .setIntersection => .unsupported "setIntersection"
  | .setDifference => .unsupported "setDifference"
  | .setMember => .unsupported "setMember"
  | .subset => .unsupported "subset"

/-- Compute sizeof for an integer type.
    Extracted from the .sizeOf case for reuse in arrayShift. -/
def sizeOfIntTypeNat : IntegerType → Option Nat
  | .bool => some 1
  | .char => some 1
  | .signed .ichar | .unsigned .ichar => some 1
  | .signed .short | .unsigned .short => some 2
  | .signed .int_ | .unsigned .int_ => some 4
  | .signed .long | .unsigned .long => some 8
  | .signed .longLong | .unsigned .longLong => some 8
  | .signed .intptr | .unsigned .intptr => some 8
  | .size_t | .ptrdiff_t | .ptraddr_t => some 8
  | .wchar_t | .wint_t => some 4
  | .enum _ => some 4
  | _ => none

/-- Compute sizeof for a C type as a Nat.
    Corresponds to: Memory.size_of_ctype in CN's solver.ml:866
    With TypeEnv, can also compute struct sizes. -/
def sizeOfCtypeNat (env : Option TypeEnv := none) : CerbLean.Core.Ctype_ → Option Nat
  | .void => some 0
  | .basic (.integer ity) => sizeOfIntTypeNat ity
  | .basic (.floating (.realFloating .float)) => some 4
  | .basic (.floating (.realFloating .double)) => some 8
  | .basic (.floating (.realFloating .longDouble)) => some 16
  | .pointer _ _ => some 8
  | .struct_ tag =>
    match env with
    | some e => some (sizeof e { ty := Ctype_.struct_ tag })
    | none => none
  | _ => none

mutual

/-- Convert a CN Term to Smt.Term.
    Type information is obtained from AnnotTerm wrappers during recursion.
    The `env` parameter provides TypeEnv for struct layout info (memberShift, offsetOf, sizeOf). -/
partial def termToSmtTerm (env : Option TypeEnv) : Types.Term → TranslateResult
  | .const c => constToTerm c
  | .sym s => .ok (Term.symbolT (symToSmtName s))
  | .unop op arg =>
    -- Pass the operand's type to unOpToTerm
    match annotTermToSmtTerm env arg with
    | .ok argTm => unOpToTerm op arg.bt argTm
    | .unsupported r => .unsupported r
  | .binop op l r =>
    -- CN's arith_binop (indexTerms.ml:597) asserts BT.equal for both operands.
    -- Types should match after the type checker.
    match annotTermToSmtTerm env l, annotTermToSmtTerm env r with
    | .ok lTm, .ok rTm =>
      binOpToTerm op l.bt r.bt lTm rTm
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .ite cond thenB elseB =>
    match annotTermToSmtTerm env cond, annotTermToSmtTerm env thenB, annotTermToSmtTerm env elseB with
    | .ok c, .ok t, .ok e => .ok (Term.mkApp3 (Term.symbolT "ite") c t e)
    | .unsupported r, _, _ => .unsupported r
    | _, .unsupported r, _ => .unsupported r
    | _, _, .unsupported r => .unsupported r
  | .eachI lo (s, bt) hi body =>
    -- Bounded quantification: use proper sort for bound variable
    let name := symToSmtName s
    match baseTypeToSort bt with
    | .unsupported reason => .unsupported s!"eachI bound variable type: {reason}"
    | .ok sort =>
      match annotTermToSmtTerm env body with
      | .ok b =>
        let rangeConstraint := Term.mkApp2 (Term.symbolT "and")
          (Term.mkApp2 (Term.symbolT ">=") (Term.symbolT name) (Term.literalT (toString lo)))
          (Term.mkApp2 (Term.symbolT "<=") (Term.symbolT name) (Term.literalT (toString hi)))
        let implBody := Term.mkApp2 (Term.symbolT "=>") rangeConstraint b
        .ok (Term.forallT name sort implBody)
      | .unsupported r => .unsupported r
  | .let_ var binding body =>
    let name := symToSmtName var
    match annotTermToSmtTerm env binding, annotTermToSmtTerm env body with
    | .ok b, .ok bd => .ok (Term.letT name b bd)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .arrayShift base ct index =>
    -- ptr_shift(base, bvmul(el_size, index), NULL)
    -- Corresponds to: solver.ml lines 865-871
    -- Index is already uintptr_bt (Bits Unsigned 64) from type checker cast
    match annotTermToSmtTerm env base, annotTermToSmtTerm env index with
    | .ok b, .ok i =>
      match sizeOfCtypeNat env ct.ty with
      | some elSize =>
        let sizeBv := mkBitVecLiteral 64 elSize
        let offset := Term.mkApp2 (Term.symbolT "bvmul") sizeBv i
        .ok (Term.mkApp3 (Term.symbolT "ptr_shift") b offset (Term.symbolT "NULL"))
      | none => .unsupported s!"arrayShift element size: {repr ct.ty}"
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .aligned ptr align =>
    -- Extract address, check divisibility with bitvector unsigned remainder
    -- Corresponds to: solver.ml lines 887-890 (addr_ + divisible_)
    match annotTermToSmtTerm env ptr, annotTermToSmtTerm env align with
    | .ok p, .ok a =>
      let addrExpr := Term.appT (Term.symbolT "addr_of") p
      let zero64 := mkBitVecLiteral 64 0
      let remainder := Term.mkApp2 (Term.symbolT "bvurem") addrExpr a
      .ok (Term.mkApp2 (Term.symbolT "=") remainder zero64)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .representable ct val =>
    -- representable(ct, val) checks if val fits in the integer type ct
    -- For BitVec types, representability is trivially true (bounded by type)
    -- For unbounded Integer types, we need explicit range checks
    let valBt := val.bt
    if isBitsType valBt then
      -- BitVec values are already bounded by their type width
      -- Representability is trivially true
      .ok (Term.symbolT "true")
    else
      -- For unbounded integers, generate range constraint
      match annotTermToSmtTerm env val with
      | .unsupported r => .unsupported r
      | .ok valTm =>
        match ct.ty with
        | .basic (.integer ity) =>
          let bounds := integerTypeBounds ity
          match bounds with
          | some (lo, hi) =>
            -- Generate: lo <= val && val < hi
            let loTm := Term.literalT (toString lo)
            let hiTm := Term.literalT (toString hi)
            let loCond := Term.mkApp2 (Term.symbolT "<=") loTm valTm
            let hiCond := Term.mkApp2 (Term.symbolT "<") valTm hiTm
            .ok (Term.mkApp2 (Term.symbolT "and") loCond hiCond)
          | none => .unsupported s!"representable for {repr ity}"
        | _ => .unsupported s!"representable for non-integer type"
  | .good ct _val =>
    -- good(ct, val) checks val is representable in ct - needs proper handling
    .unsupported s!"good (type check for {repr ct.ty})"
  | .wrapI _intType val =>
    -- wrapI wraps integer value to representation type (modular arithmetic)
    -- Corresponds to: wrapI in CN's indexTerms.ml
    -- For bitvec SMT sorts, modular wrapping is enforced by the sort itself,
    -- so this is identity. If we ever use unbounded integer sorts, this would
    -- need explicit modular arithmetic (bvmod or similar).
    match annotTermToSmtTerm env val with
    | .unsupported r => .unsupported r
    | .ok valTm => .ok valTm
  | .cast targetType val =>
    -- cast changes type between CN base types
    -- Corresponds to: cast_ in CN's indexTerms.ml
    match annotTermToSmtTerm env val with
    | .unsupported r => .unsupported r
    | .ok valTm =>
      let sourceBt := val.bt
      match sourceBt, targetType with
      | .bits _ sw, .bits _ tw =>
        if sw == tw then .ok valTm  -- Same width: identity
        else if sw < tw then
          -- Extend: use zero_extend (indexed identifier)
          let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend") (Term.literalT (toString (tw - sw)))
          .ok (Term.appT zeroExt valTm)
        else
          -- Truncate: use extract (indexed identifier with two args: high, low)
          let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract") (Term.literalT (toString (tw - 1))) (Term.literalT "0")
          .ok (Term.appT extract valTm)
      | .integer, .bits _ tw =>
        -- Int → BitVec: use int2bv (indexed identifier)
        -- Use literalT because Smt library's appToList doesn't special-case int2bv
        let int2bv := Term.literalT s!"(_ int2bv {tw})"
        .ok (Term.appT int2bv valTm)
      | .loc, .bits _ tw =>
        -- Loc → BitVec: extract address via addr_of, then possibly resize
        -- Corresponds to: solver.ml lines 965-972
        let addr := Term.appT (Term.symbolT "addr_of") valTm
        if tw == 64 then .ok addr  -- Already uintptr_bt width
        else if tw < 64 then
          -- Truncate: extract [tw-1:0]
          let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract")
            (Term.literalT (toString (tw - 1))) (Term.literalT "0")
          .ok (Term.appT extract addr)
        else
          -- Extend: zero_extend to wider width
          let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend")
            (Term.literalT (toString (tw - 64)))
          .ok (Term.appT zeroExt addr)
      | .loc, .allocId =>
        -- Loc → AllocId: extract allocation ID
        -- Corresponds to: solver.ml line 973-974
        .ok (Term.mkApp2 (Term.symbolT "alloc_id_of") valTm (Term.literalT "0"))
      | .bits _ _, .integer =>
        -- BitVec → Int: use bv2int
        .ok (Term.appT (Term.symbolT "bv2int") valTm)
      | .bits _ sw, .loc =>
        -- BitVec → Loc: use bits_to_ptr with default alloc_id=0
        -- Corresponds to: solver.ml lines 957-964
        let castBits :=
          if sw == 64 then valTm
          else if sw < 64 then
            -- Extend to 64 bits for pointer width
            let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend")
              (Term.literalT (toString (64 - sw)))
            Term.appT zeroExt valTm
          else
            -- Truncate to 64 bits
            let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract")
              (Term.literalT "63") (Term.literalT "0")
            Term.appT extract valTm
        .ok (Term.mkApp2 (Term.symbolT "bits_to_ptr") castBits (Term.literalT "0"))
      | _, _ =>
        .unsupported s!"cast from {repr sourceBt} to {repr targetType}"
  | .copyAllocId addr loc =>
    -- copy_alloc_id(loc_ptr, addr_bitvec, NULL)
    -- Note: `loc` is the pointer to copy alloc_id FROM, `addr` is the new address
    -- Corresponds to: solver.ml lines 872-876
    match annotTermToSmtTerm env addr, annotTermToSmtTerm env loc with
    | .ok addrTm, .ok locTm =>
      .ok (Term.mkApp3 (Term.symbolT "copy_alloc_id") locTm addrTm (Term.symbolT "NULL"))
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .hasAllocId ptr =>
    -- ((_ is AiA) ptr) — tests if pointer has allocation ID (is non-null)
    -- Corresponds to: solver.ml line 877
    match annotTermToSmtTerm env ptr with
    | .ok p =>
      let isAiA := Term.literalT "(_ is AiA)"
      .ok (Term.appT isAiA p)
    | .unsupported r => .unsupported r
  | .sizeOf ct =>
    -- sizeOf(ctype) as a concrete integer
    -- With TypeEnv, can also compute struct sizes
    match sizeOfCtypeNat env ct.ty with
    | some n => .ok (Term.literalT (toString n))
    | none => .unsupported s!"sizeOf ({repr ct.ty})"
  | .offsetOf tag member =>
    -- Compute offset as BitVec 64 literal from struct layout
    -- Corresponds to: solver.ml lines 828-831
    let tagStr := tag.name.getD "?"
    match env with
    | none => .unsupported s!"offsetOf ({tagStr}, {member.name}): no TypeEnv"
    | some e =>
      match e.lookupTag tag with
      | some (.struct_ members _) =>
        let offsets := structOffsets e members
        match offsets.find? (·.1 == member) with
        | some (_, offset) => .ok (mkBitVecLiteral 64 offset)
        | none => .unsupported s!"offsetOf: member {member.name} not found in struct {tagStr}"
      | some (.union_ _) => .ok (mkBitVecLiteral 64 0)  -- All union members at offset 0
      | _ => .unsupported s!"offsetOf: tag {tagStr} not found"
  | .memberShift ptr tag member =>
    -- ptr_shift(ptr, offset, NULL) where offset = offsetOf(tag, member)
    -- Corresponds to: solver.ml lines 860-864
    let tagStr := tag.name.getD "?"
    match annotTermToSmtTerm env ptr with
    | .unsupported r => .unsupported r
    | .ok p =>
      match env with
      | none => .unsupported s!"memberShift ({tagStr}, {member.name}): no TypeEnv"
      | some e =>
        match e.lookupTag tag with
        | some (.struct_ members _) =>
          let offsets := structOffsets e members
          match offsets.find? (·.1 == member) with
          | some (_, offset) =>
            let offsetBv := mkBitVecLiteral 64 offset
            .ok (Term.mkApp3 (Term.symbolT "ptr_shift") p offsetBv (Term.symbolT "NULL"))
          | none => .unsupported s!"memberShift: member {member.name} not found in struct {tagStr}"
        | some (.union_ _) =>
          -- Union members all at offset 0 — ptr_shift by 0
          let zeroBv := mkBitVecLiteral 64 0
          .ok (Term.mkApp3 (Term.symbolT "ptr_shift") p zeroBv (Term.symbolT "NULL"))
        | _ => .unsupported s!"memberShift: tag {tagStr} not found"
  | .cnSome val => annotTermToSmtTerm env val
  | .getOpt opt => annotTermToSmtTerm env opt
  | .apply fn args =>
    let fnName := symToSmtName fn
    let rec buildApp (acc : Smt.Term) : List AnnotTerm → TranslateResult
      | [] => .ok acc
      | arg :: rest =>
        match annotTermToSmtTerm env arg with
        | .ok argTm => buildApp (Term.appT acc argTm) rest
        | .unsupported r => .unsupported r
    buildApp (Term.symbolT fnName) args
  | .tuple elems =>
    -- Support single-element tuples (common in return value handling)
    match elems with
    | [single] => annotTermToSmtTerm env single
    | _ => .unsupported s!"tuple with {elems.length} elements"
  | .nthTuple n tup =>
    -- Support projecting from tuples
    match tup.term with
    | .tuple elems =>
      if h : n < elems.length then
        annotTermToSmtTerm env (elems.get ⟨n, h⟩)
      else
        .unsupported s!"nthTuple index {n} out of bounds for tuple of size {elems.length}"
    | _ =>
      .unsupported s!"nthTuple on non-tuple term (index {n}, term type {repr tup.bt})"
  | .struct_ _ _ => .unsupported "struct"
  | .structMember _ _ => .unsupported "structMember"
  | .structUpdate _ _ _ => .unsupported "structUpdate"
  | .record _ => .unsupported "record"
  | .recordMember _ _ => .unsupported "recordMember"
  | .recordUpdate _ _ _ => .unsupported "recordUpdate"
  | .constructor _ _ => .unsupported "constructor"
  | .nil _ => .unsupported "nil"
  | .cons _ _ => .unsupported "cons"
  | .head _ => .unsupported "head"
  | .tail _ => .unsupported "tail"
  | .mapConst _ _ => .unsupported "mapConst"
  | .mapSet _ _ _ => .unsupported "mapSet"
  | .mapGet _ _ => .unsupported "mapGet"
  | .mapDef _ _ => .unsupported "mapDef"
  | .match_ scrutinee cases =>
    -- Support match patterns from CN.
    -- For tuple destructuring, we create SMT let-bindings that tie pattern
    -- variables to the corresponding scrutinee components.
    -- Corresponds to: match handling in CN's solver translation
    match cases with
    | [] => .unsupported "match with no cases"
    | (pat, body) :: rest =>
      -- Try to create let-bindings from pattern + scrutinee
      match extractPatternBindings env pat scrutinee with
      | .error r => .unsupported s!"match pattern bindings: {r}"
      | .ok bindings =>
        let bodyTm := annotTermToSmtTerm env body
        match bodyTm with
        | .unsupported r => .unsupported r
        | .ok bodySmtTm =>
          if bindings.isEmpty then
            -- No bindings to create
            if rest.isEmpty then .ok bodySmtTm
            else if scrutinee.bt matches .bool then
              -- Boolean match: use if-then-else
              match rest with
              | [(_, body2)] =>
                match annotTermToSmtTerm env scrutinee, annotTermToSmtTerm env body2 with
                | .ok s, .ok b2 => .ok (Term.mkApp3 (Term.symbolT "ite") s bodySmtTm b2)
                | .unsupported r, _ => .unsupported r
                | _, .unsupported r => .unsupported r
              | _ => .unsupported s!"match on boolean with {rest.length + 1} cases (expected 2)"
            else .unsupported s!"match on non-boolean ({repr scrutinee.bt}) with {rest.length + 1} cases"
          else
            -- Create nested let-bindings for pattern variables
            let result := bindings.foldl (init := bodySmtTm) fun acc (name, valTm) =>
              Term.letT name valTm acc
            .ok result
  | .cnNone _ => .unsupported "cnNone"
  | .isSome _ => .unsupported "isSome"

/-- Convert an AnnotTerm to Smt.Term -/
partial def annotTermToSmtTerm (env : Option TypeEnv) (at_ : AnnotTerm) : TranslateResult :=
  termToSmtTerm env at_.term

/-- Extract pattern bindings from a match: pairs of (smt_name, scrutinee_component_term).
    For a tuple destructuring match, this creates let-bindings that tie
    pattern variables to the corresponding scrutinee components. -/
partial def extractPatternBindings (env : Option TypeEnv) (pat : Types.Pattern) (scrutinee : AnnotTerm)
    : Except String (List (String × Smt.Term)) :=
  match pat.pat with
  | .sym s =>
    -- Single variable pattern: bind to whole scrutinee
    match annotTermToSmtTerm env scrutinee with
    | .ok tm => .ok [(symToSmtName s, tm)]
    | .unsupported r => .error s!"pattern binding: {r}"
  | .constructor _ctor args =>
    -- Constructor pattern: handle tuple destructuring and wrappers like Specified(x)
    match scrutinee.term with
    | .tuple components =>
      -- Tuple destructuring: match up pattern args with tuple components
      let pairs := args.zip components
      let results := pairs.map fun ((_, subPat), component) =>
        extractPatternBindings env subPat component
      -- Collect all results, propagating any errors
      let collected := results.foldl (init := Except.ok ([] : List (String × Smt.Term))) fun acc r =>
        match acc, r with
        | .error e, _ => .error e
        | _, .error e => .error e
        | .ok ls, .ok rs => .ok (ls ++ rs)
      collected
    | _ =>
      -- Non-tuple scrutinee: for single-arg constructors (like Specified(x)),
      -- unwrap and bind the inner pattern to the scrutinee directly
      match args with
      | [(_, innerPat)] => extractPatternBindings env innerPat scrutinee
      | _ => .error s!"constructor pattern with {args.length} args on non-tuple scrutinee"
  | .wild => .ok []  -- Wildcard: no binding

end

/-- Convert a LogicalConstraint to Smt.Term -/
def constraintToSmtTerm (env : Option TypeEnv := none) : LogicalConstraint → TranslateResult
  | .t it => annotTermToSmtTerm env it
  | .forall_ (s, bt) body =>
    let name := symToSmtName s
    match baseTypeToSort bt with
    | .unsupported reason => .unsupported s!"forall bound variable type: {reason}"
    | .ok sort =>
      match annotTermToSmtTerm env body with
      | .ok b => .ok (Term.forallT name sort b)
      | .unsupported r => .unsupported r

/-! ## Free Symbol Collection with Types

We collect (Sym, BaseType) pairs to generate properly-typed SMT declarations.
CN uses actual SMT-LIB BitVec types for Bits, so we generate declarations like
`(declare-const v (_ BitVec 32))` instead of `(declare-const v Int)`.
-/

/-- A typed symbol for SMT generation -/
abbrev TypedSym := Sym × BaseType

mutual

/-- Collect free symbols with types from an AnnotTerm.
    Returns (Sym, BaseType) pairs where BaseType comes from the term's annotation. -/
partial def annotTermFreeTypedSyms (at_ : AnnotTerm) : List TypedSym :=
  match at_.term with
  | .sym s => [(s, at_.bt)]
  | .const _ => []
  | .unop _ arg => annotTermFreeTypedSyms arg
  | .binop _ l r => annotTermFreeTypedSyms l ++ annotTermFreeTypedSyms r
  | .ite c t e => annotTermFreeTypedSyms c ++ annotTermFreeTypedSyms t ++ annotTermFreeTypedSyms e
  | .eachI _ (s, _) _ body => (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .tuple elems => elems.flatMap annotTermFreeTypedSyms
  | .nthTuple _ tup => annotTermFreeTypedSyms tup
  | .struct_ _ members => members.flatMap (annotTermFreeTypedSyms ·.2)
  | .structMember obj _ => annotTermFreeTypedSyms obj
  | .structUpdate obj _ val => annotTermFreeTypedSyms obj ++ annotTermFreeTypedSyms val
  | .record members => members.flatMap (annotTermFreeTypedSyms ·.2)
  | .recordMember obj _ => annotTermFreeTypedSyms obj
  | .recordUpdate obj _ val => annotTermFreeTypedSyms obj ++ annotTermFreeTypedSyms val
  | .constructor _ args => args.flatMap (annotTermFreeTypedSyms ·.2)
  | .memberShift ptr _ _ => annotTermFreeTypedSyms ptr
  | .arrayShift base _ idx => annotTermFreeTypedSyms base ++ annotTermFreeTypedSyms idx
  | .copyAllocId addr loc => annotTermFreeTypedSyms addr ++ annotTermFreeTypedSyms loc
  | .hasAllocId ptr => annotTermFreeTypedSyms ptr
  | .sizeOf _ => []
  | .offsetOf _ _ => []
  | .nil _ => []
  | .cons h t => annotTermFreeTypedSyms h ++ annotTermFreeTypedSyms t
  | .head l => annotTermFreeTypedSyms l
  | .tail l => annotTermFreeTypedSyms l
  | .representable _ val => annotTermFreeTypedSyms val
  | .good _ val => annotTermFreeTypedSyms val
  | .aligned ptr align => annotTermFreeTypedSyms ptr ++ annotTermFreeTypedSyms align
  | .wrapI _ val => annotTermFreeTypedSyms val
  | .mapConst _ val => annotTermFreeTypedSyms val
  | .mapSet m k v => annotTermFreeTypedSyms m ++ annotTermFreeTypedSyms k ++ annotTermFreeTypedSyms v
  | .mapGet m k => annotTermFreeTypedSyms m ++ annotTermFreeTypedSyms k
  | .mapDef (s, _) body => (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .apply _ args => args.flatMap annotTermFreeTypedSyms
  | .let_ s binding body =>
    annotTermFreeTypedSyms binding ++ (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .match_ scrut cases =>
    annotTermFreeTypedSyms scrut ++ cases.flatMap (annotTermFreeTypedSyms ·.2)
  | .cast _ val => annotTermFreeTypedSyms val
  | .cnNone _ => []
  | .cnSome val => annotTermFreeTypedSyms val
  | .isSome opt => annotTermFreeTypedSyms opt
  | .getOpt opt => annotTermFreeTypedSyms opt

end

/-- Collect free symbols with types from a LogicalConstraint -/
def constraintFreeTypedSyms : LogicalConstraint → List TypedSym
  | .t it => annotTermFreeTypedSyms it
  | .forall_ (s, _bt) body =>
    -- The bound variable has the given type, but we filter it out
    (annotTermFreeTypedSyms body).filter (·.1 != s)

/-- Deduplicate typed symbols, keeping the first occurrence of each symbol -/
def deduplicateTypedSyms (syms : List TypedSym) : List TypedSym :=
  syms.foldl (fun acc (s, bt) =>
    if acc.any (·.1 == s) then acc else acc ++ [(s, bt)]
  ) []

/-- Collect all free symbols with types from an obligation -/
def obligationFreeTypedSyms (ob : Obligation) : List TypedSym :=
  let assumptionSyms := ob.assumptions.flatMap constraintFreeTypedSyms
  let constraintSyms := constraintFreeTypedSyms ob.constraint
  deduplicateTypedSyms (assumptionSyms ++ constraintSyms)

/-- Legacy: Collect free symbols without types (for backwards compatibility) -/
def annotTermFreeSyms (at_ : AnnotTerm) : List Sym :=
  (annotTermFreeTypedSyms at_).map (·.1)

/-- Legacy: Collect free symbols from a constraint -/
def constraintFreeSyms (lc : LogicalConstraint) : List Sym :=
  (constraintFreeTypedSyms lc).map (·.1)

/-- Legacy: Collect all free symbols from an obligation -/
def obligationFreeSyms (ob : Obligation) : List Sym :=
  (obligationFreeTypedSyms ob).map (·.1)

/-! ## Query Building -/

/-- Build SMT commands for an obligation.
    Returns the commands and any unsupported constructs encountered.

    Uses proper SMT-LIB types: Bits symbols are declared with `(_ BitVec n)`,
    matching CN's approach in solver.ml.
    Corresponds to: CN's solver.ml translate_global_decls -/
def obligationToCommands (ob : Obligation) (env : Option TypeEnv := none)
    : List Command × List String :=
  let typedSyms := obligationFreeTypedSyms ob

  -- Generate declarations with proper SMT sorts (BitVec for Bits types)
  -- Collect errors for symbols with unsupported types
  let (decls, declErrors) := typedSyms.foldl (fun (cmds, errs) (s, bt) =>
    match baseTypeToSort bt with
    | .ok sort => (cmds ++ [Command.declare (symToSmtName s) sort], errs)
    | .unsupported reason => (cmds, errs ++ [s!"symbol {symToSmtName s}: {reason}"])
  ) ([], [])

  -- Translate assumptions
  let (assumptionTerms, assumptionErrors) := ob.assumptions.foldl
    (fun (terms, errs) lc =>
      match constraintToSmtTerm env lc with
      | .ok tm => (tm :: terms, errs)
      | .unsupported r =>
        -- Include the source constraint description in the error
        let lcDesc := match lc with
          | .t at_ => s!"bt={repr at_.bt}"
          | .forall_ _ _ => "forall"
        (terms, s!"{r} (from: {lcDesc})" :: errs))
    ([], [])

  -- No need for explicit range constraints - BitVec types handle this
  let allAssumptions := assumptionTerms.reverse

  -- Build conjunction of assumptions (or "true" if empty)
  let assumptionConj :=
    match allAssumptions with
    | [] => Term.symbolT "true"
    | [single] => single
    | first :: rest => rest.foldl (fun acc tm =>
        Term.mkApp2 (Term.symbolT "and") acc tm) first

  -- Translate goal
  let (goalTerm, goalErrors) :=
    match constraintToSmtTerm env ob.constraint with
    | .ok tm => (tm, [])
    | .unsupported r => (Term.symbolT "false", [r])

  let allErrors :=
    (declErrors.map (s!"[decl] " ++ ·)) ++
    (assumptionErrors.reverse.map (s!"[assumption] " ++ ·)) ++
    (goalErrors.map (s!"[goal] " ++ ·))

  -- Build implication: assumptions => goal
  let implication := Term.mkApp2 (Term.symbolT "=>") assumptionConj goalTerm

  -- Assert negation (checking if the implication can be falsified)
  let assertion := Command.assert (Term.appT (Term.symbolT "not") implication)

  let commands := decls ++ [assertion, Command.checkSat]

  (commands, allErrors)

/-- Convert obligation to SMT-LIB2 query string.
    Prepends the pointer datatype preamble before declarations. -/
def obligationToSmtLib2 (ob : Obligation) (env : Option TypeEnv := none)
    : String × List String :=
  let (cmds, errors) := obligationToCommands ob env
  let queryStr := Command.cmdsAsQuery cmds
  let withComment := s!"; Obligation: {ob.description}\n{pointerPreamble}{queryStr}"
  (withComment, errors)

/-- Serialize multiple obligations, each as a separate query -/
def obligationsToSmtLib2 (obs : List Obligation) (env : Option TypeEnv := none)
    : List (Obligation × String × List String) :=
  obs.map fun ob =>
    let (smt, errors) := obligationToSmtLib2 ob env
    (ob, smt, errors)

end CerbLean.CN.Verification.SmtLib
