/-
  SMT-LIB2 Translation for CN Proof Obligations

  This module translates CN proof obligations to SMT-LIB2 format using
  the lean-smt library infrastructure.

  ## Architecture

  We translate CN's IndexTerm to Smt.Term, then use lean-smt's
  Command infrastructure to build queries.

  For an obligation with assumptions [A1, A2, ...] and constraint C,
  we generate:
  - Declarations for all free symbols
  - Assert (not (=> (and A1 A2 ...) C))
  - check-sat

  If the solver returns "unsat", the obligation is discharged.

  Audited: 2026-01-27 (pragmatic pipeline using lean-smt)
-/

import CerbLean.CN.Types
import CerbLean.CN.TypeChecking.Resolve
import CerbLean.CN.Verification.Obligation
import CerbLean.Memory.Layout
import Smt.Translate.Term
import Smt.Translate.Commands
import Smt.Data.Sexp

namespace CerbLean.CN.Verification.SmtLib

open CerbLean.Core (Sym Identifier Loc Ctype Ctype_ IntegerType TagDef FieldDef)
open CerbLean.CN.Types
open CerbLean.CN.TypeChecking.Resolve (ctypeToOutputBaseType)
open CerbLean.Memory (TypeEnv structOffsets sizeof)
open Smt (Term)
open Smt.Translate (Command)

/-! ## Symbol Name Generation -/

/-- Generate a valid SMT-LIB2 identifier from a Sym -/
def symToSmtName (s : Sym) : String :=
  match s.name with
  | some n => s!"{n}_{s.id}"
  | none => s!"_sym_{s.id}"

/-! ## Pointer Model Preamble

CN encodes pointers as an algebraic datatype in SMT (solver.ml:241-351):
- NULL: the null pointer
- AiA(alloc_id, addr): pointer with allocation ID (Int, VIP mode) and address (BitVec 64)

Five helper functions: ptr_shift, copy_alloc_id, alloc_id_of, bits_to_ptr, addr_of.
These use selector functions (alloc_id, addr) auto-generated by declare-datatype.
-/

/-! ### CN_Tuple Preamble

CN represents tuples as parametric SMT algebraic datatypes (solver.ml:127-167).
`cn_tuple_N` has N type parameters, one constructor (same name), and N selectors
`cn_get_I_of_N`. Arity 0 is also used for Unit (solver.ml:405).

Audited: 2026-02-18
-/

/-- Maximum tuple arity to declare, matching CN_Tuple.max_arity (solver.ml:128) -/
private def maxTupleArity : Nat := 15

/-- Generate declare-datatype for cn_tuple_N.
    Non-parametric for arity 0; parametric for arity >= 1.
    Corresponds to: CN_Tuple.declare in solver.ml:147-155 -/
private def declareTupleN (arity : Nat) : String :=
  let name := s!"cn_tuple_{arity}"
  if arity == 0 then
    s!"(declare-datatype {name} (({name})))\n"
  else
    let params := (List.range arity).map fun i => s!"a{i}"
    let paramStr := String.intercalate " " params
    let fields := (List.range arity).map fun i =>
      s!"(cn_get_{i}_of_{arity} a{i})"
    let fieldStr := String.intercalate " " fields
    s!"(declare-datatype {name} (par ({paramStr}) (({name} {fieldStr}))))\n"

/-- Generate all tuple datatype declarations (arity 0 to maxTupleArity).
    Corresponds to: CN_Tuple.declare in solver.ml:147-155 -/
def tuplePreamble : String :=
  String.join ((List.range (maxTupleArity + 1)).map declareTupleN)

/-! ### CN_List Preamble

CN represents lists as a parametric ADT with nil and cons constructors (solver.ml:369-399).
Audited: 2026-02-18
-/

/-- SMT-LIB2 declaration for cn_list parametric datatype.
    Corresponds to: CN_List.declare in solver.ml:382-389 -/
def listPreamble : String :=
  "(declare-datatype cn_list (par (a) ((cn_nil) (cn_cons (cn_head a) (cn_tail (cn_list a))))))\n"

/-! ### CN_Option Preamble

CN represents options as a parametric ADT with none and some constructors (solver.ml:180-208).
Audited: 2026-02-18
-/

/-- SMT-LIB2 declaration for cn_option parametric datatype.
    Corresponds to: CN_Option.declare in solver.ml:191-198 -/
def optionPreamble : String :=
  "(declare-datatype cn_option (par (a) ((cn_none) (cn_some (cn_val a)))))\n"

/-! ### CN_MemByte Preamble

CN represents memory bytes as an ADT with alloc_id (optional) and value (BitVec 8)
(solver.ml:210-239). bits_per_byte = 8 (memory.ml:14).
Audited: 2026-02-18
-/

/-- SMT-LIB2 declaration for mem_byte datatype.
    Uses cn_option Int for alloc_id (VIP mode) and BitVec 8 for value.
    Corresponds to: CN_MemByte.declare in solver.ml:228-238 -/
def memBytePreamble : String :=
  "(declare-datatype mem_byte ((AiV (alloc_id (cn_option Int)) (value (_ BitVec 8)))))\n"

/-! ### CN_Pointer Preamble

CN represents pointers as an ADT with NULL and AiA(alloc_id, addr) constructors,
plus helper functions (solver.ml:241-351).
Audited: 2026-02-18
-/

/-- SMT-LIB2 preamble declaring the pointer datatype and helper functions.
    Must be emitted before any declarations or assertions in every query.
    Corresponds to: CN_Pointer.declare in solver.ml lines 290-351 -/
def pointerPreamble : String :=
  -- Pointer datatype (solver.ml:290-300)
  "(declare-datatype pointer ((NULL) (AiA (alloc_id Int) (addr (_ BitVec 64)))))\n" ++
  -- ptr_shift: shift pointer by bitvec offset (solver.ml:303-310)
  "(define-fun ptr_shift ((p pointer) (offset (_ BitVec 64)) (null_case pointer)) pointer\n" ++
  "  (ite ((_ is NULL) p) null_case (AiA (alloc_id p) (bvadd (addr p) offset))))\n" ++
  -- copy_alloc_id: copy alloc_id from p onto new_addr (solver.ml:314-321)
  "(define-fun copy_alloc_id ((p pointer) (new_addr (_ BitVec 64)) (null_case pointer)) pointer\n" ++
  "  (ite ((_ is NULL) p) null_case (AiA (alloc_id p) new_addr)))\n" ++
  -- alloc_id_of: extract alloc_id (solver.ml:325-331)
  "(define-fun alloc_id_of ((p pointer) (null_case Int)) Int\n" ++
  "  (ite ((_ is NULL) p) null_case (alloc_id p)))\n" ++
  -- bits_to_ptr: convert BitVec to pointer (solver.ml:335-341)
  "(define-fun bits_to_ptr ((bits (_ BitVec 64)) (aid Int)) pointer\n" ++
  "  (ite (= bits (_ bv0 64)) NULL (AiA aid bits)))\n" ++
  -- addr_of: extract address as BitVec 64 (solver.ml:345-351)
  "(define-fun addr_of ((p pointer)) (_ BitVec 64)\n" ++
  "  (ite ((_ is NULL) p) (_ bv0 64) (addr p)))\n"

/-- Complete solver basics preamble: declares all ADT types in the correct order.
    Order matches CN's declare_solver_basics (solver.ml:1098-1104):
    CN_Tuple, CN_List, CN_Option, CN_MemByte, CN_Pointer.
    Audited: 2026-02-18 -/
def solverBasicsPreamble : String :=
  tuplePreamble ++ listPreamble ++ optionPreamble ++ memBytePreamble ++ pointerPreamble

/-! ## Uninterpreted Function Preamble for *NoSMT Operations

CN translates `mulNoSMT`, `divNoSMT`, `expNoSMT`, `remNoSMT`, `modNoSMT` as
uninterpreted functions rather than actual arithmetic operations.

For each *NoSMT operation and each supported base type, CN declares:
  `(declare-fun <op>_uf_<bt_suffix> (<sort> <sort>) <sort>)`
where `<bt_suffix>` is the BT.pp name (e.g., `i32`, `u64`, `integer`).

Corresponds to: CN_Functions.declare_arith_uf_functions in solver.ml:1070-1081
and CN_Names.mul/div/exp/rem/mod' in solver.ml:32-40
Audited: 2026-02-18
-/

/-- Convert a BaseType to the CN BT.pp-style suffix used in uninterpreted function names.
    Corresponds to: BT.pp in baseTypes.ml:43-52
    Returns none for types that CN doesn't declare UF functions for. -/
private def baseTypeUfSuffix : BaseType → Option String
  | .bits .signed w => some s!"i{w}"
  | .bits .unsigned w => some s!"u{w}"
  | .integer => some "integer"
  | _ => none

/-- Convert a BaseType to the SMT sort string for use in declare-fun.
    Matches baseTypeToSortString but for UF preamble generation. -/
private def baseTypeToUfSort : BaseType → Option String
  | .bits _ w => some s!"(_ BitVec {w})"
  | .integer => some "Int"
  | _ => none

/-- Generate SMT-LIB2 preamble declaring uninterpreted functions for *NoSMT operations.
    CN declares these for all combinations of {mul, div, exp, rem, mod} × {i8, u8, i16, u16,
    i32, u32, i64, u64, i128, u128, integer}.
    Corresponds to: CN_Functions.declare_arith_uf_functions in solver.ml:1070-1081 -/
def uninterpFunctionPreamble : String :=
  let ops := ["mul", "div", "exp", "rem", "mod"]
  let sizes := [8, 16, 32, 64, 128]
  let bitBts : List BaseType :=
    sizes.flatMap fun sz => [BaseType.bits .signed sz, BaseType.bits .unsigned sz]
  let allBts := BaseType.integer :: bitBts
  let decls := ops.flatMap fun op =>
    allBts.filterMap fun bt =>
      match baseTypeUfSuffix bt, baseTypeToUfSort bt with
      | some suffix, some sort =>
        some s!"(declare-fun {op}_uf_{suffix} ({sort} {sort}) {sort})\n"
      | _, _ => none
  String.join decls

/-! ## Struct SMT Support

CN declares each struct as an SMT datatype with a single constructor and
selector functions for each field (solver.ml:1035-1067, CN_Structs).

Naming conventions (solver.ml:15-24, CN_Names):
- Struct sort name: `tag_name ++ "_" ++ tag_id`
- Constructor name: same as sort name
- Field selector: `member_name ++ "_struct_fld"`
-/

/-- Generate SMT struct type/constructor name from tag symbol.
    Corresponds to: CN_Names.struct_name / struct_con_name in solver.ml:20-22 -/
def structSmtName (tag : Sym) : String :=
  match tag.name with
  | some name => s!"{name}_{tag.id}"
  | none => panic! s!"structSmtName: tag symbol has no name (id={tag.id})"

/-- Generate SMT field selector name from member identifier.
    Corresponds to: CN_Names.struct_field_name in solver.ml:24 -/
def structFieldName (member : Identifier) : String :=
  s!"{member.name}_struct_fld"

/-- Convert a CN BaseType to an SMT sort string for struct field declarations.
    Used when generating struct datatype declarations.
    Corresponds to: translate_base_type in solver.ml:404-421
    Audited: 2026-02-18 -/
private partial def baseTypeToSortString : BaseType → Option String
  | .bits _ width => some s!"(_ BitVec {width})"
  | .integer => some "Int"
  | .bool => some "Bool"
  | .real => some "Real"
  | .loc => some "pointer"
  | .allocId => some "Int"  -- VIP mode (solver.ml:412)
  | .unit => some "cn_tuple_0"  -- Unit = empty tuple (solver.ml:405)
  | .memByte => some "mem_byte"  -- CN_MemByte ADT (solver.ml:408)
  | .ctype => some "Int"  -- CN encodes CType as Int (solver.ml:413)
  | .struct_ tag => some (structSmtName tag)
  | .list elemBt =>
    (baseTypeToSortString elemBt).map fun elemSort => s!"(cn_list {elemSort})"
  | .option innerBt =>
    (baseTypeToSortString innerBt).map fun innerSort => s!"(cn_option {innerSort})"
  | .tuple bts =>
    let arity := bts.length
    if arity > maxTupleArity then none
    else
      let innerSorts := bts.filterMap baseTypeToSortString
      if innerSorts.length != bts.length then none
      else some s!"(cn_tuple_{arity} {String.intercalate " " innerSorts})"
  | .record members =>
    -- CN encodes records as tuples (solver.ml:421)
    baseTypeToSortString (.tuple (members.map (·.2)))
  | .map keyBt valBt =>
    -- CN encodes maps as SMT arrays (solver.ml:416)
    match baseTypeToSortString keyBt, baseTypeToSortString valBt with
    | some k, some v => some s!"(Array {k} {v})"
    | _, _ => none
  | .set elemBt =>
    -- CN encodes sets as SMT sets (solver.ml:415)
    (baseTypeToSortString elemBt).map fun elemSort => s!"(Set {elemSort})"
  | .datatype _ => none

/-- Generate SMT-LIB2 declare-datatype for a struct.
    Produces: (declare-datatype name ((name (f1 sort1) (f2 sort2) ...)))
    Corresponds to: CN_Structs.declare_struct in solver.ml:1036-1061
    Returns none if any field type is unsupported. -/
def generateStructDeclaration (tag : Sym) (members : List FieldDef) : Option String :=
  let name := structSmtName tag
  let fieldStrs := members.filterMap fun m =>
    let bt := ctypeToOutputBaseType m.ty
    (baseTypeToSortString bt).map fun sortStr =>
      s!" ({structFieldName m.name} {sortStr})"
  -- If any member type was unsupported (filterMap dropped it), check count
  if fieldStrs.length != members.length then none
  else
    let fields := String.join fieldStrs
    some s!"(declare-datatype {name} (({name}{fields})))\n"

/-- Generate SMT preamble for all struct definitions in a TypeEnv.
    Iterates tagDefs and generates declare-datatype for each struct.
    Corresponds to: CN_Structs.declare in solver.ml:1064-1066 -/
def generateStructPreamble (env : TypeEnv) : String :=
  env.tagDefs.foldl (init := "") fun acc (tag, _, td) =>
    match td with
    | .struct_ members _ =>
      match generateStructDeclaration tag members with
      | some decl => acc ++ decl
      | none => acc  -- Skip structs with unsupported field types
    | .union_ _ => acc  -- CN does not support unions (check.ml:200)

/-! ## Type-to-Sort Translation

CN uses actual SMT-LIB BitVec types (`(_ BitVec n)`) with bitvector operations.
We must match this exactly.

Corresponds to: CN's solver.ml translate_bt function
-/

/-- Result of sort translation -/
inductive SortResult where
  | ok (tm : Smt.Term)
  | unsupported (reason : String)
  deriving Inhabited

/-- Convert CN BaseType to SMT-LIB2 sort.
    Matches CN's translate_base_type (solver.ml:404-421).
    Uses Smt.Term representation for sorts.
    Audited: 2026-02-18 -/
partial def baseTypeToSort : BaseType → SortResult
  | .bits _ width => .ok (Term.mkApp2 (Term.symbolT "_")
                                  (Term.symbolT "BitVec")
                                  (Term.literalT (toString width)))
  | .integer => .ok (Term.symbolT "Int")
  | .bool => .ok (Term.symbolT "Bool")
  | .real => .ok (Term.symbolT "Real")
  | .loc => .ok (Term.symbolT "pointer")  -- CN pointer algebraic datatype (solver.ml:411)
  | .allocId => .ok (Term.symbolT "Int")  -- VIP mode: allocation IDs as integers (solver.ml:412)
  | .unit => .ok (Term.symbolT "cn_tuple_0")  -- Unit as empty tuple (solver.ml:405)
  | .memByte => .ok (Term.symbolT "mem_byte")  -- CN_MemByte ADT (solver.ml:408)
  | .ctype => .ok (Term.symbolT "Int")  -- CN encodes CType as Int (solver.ml:413)
  | .struct_ tag =>
    .ok (Term.symbolT (structSmtName tag))
  | .list elemBt =>
    match baseTypeToSort elemBt with
    | .ok elemSort => .ok (Term.appT (Term.symbolT "cn_list") elemSort)  -- solver.ml:414
    | .unsupported r => .unsupported s!"list element type: {r}"
  | .option innerBt =>
    match baseTypeToSort innerBt with
    | .ok innerSort => .ok (Term.appT (Term.symbolT "cn_option") innerSort)  -- solver.ml:420
    | .unsupported r => .unsupported s!"option inner type: {r}"
  | .tuple bts =>
    -- CN_Tuple.t (solver.ml:417): cn_tuple_N applied to element sorts
    if bts.length > maxTupleArity then
      .unsupported s!"tuple arity {bts.length} exceeds max {maxTupleArity}"
    else
      let results := bts.map baseTypeToSort
      match results.find? (· matches .unsupported _) with
      | some (.unsupported r) => .unsupported s!"tuple element type: {r}"
      | _ =>
        let sorts := results.filterMap fun r => match r with | .ok t => some t | _ => none
        let base := Term.symbolT s!"cn_tuple_{bts.length}"
        .ok (sorts.foldl (fun acc s => Term.appT acc s) base)
  | .record members =>
    -- CN encodes records as tuples of value types (solver.ml:421)
    baseTypeToSort (.tuple (members.map (·.2)))
  | .map keyBt valBt =>
    -- CN uses SMT arrays (solver.ml:416)
    match baseTypeToSort keyBt, baseTypeToSort valBt with
    | .ok kSort, .ok vSort => .ok (Term.mkApp2 (Term.symbolT "Array") kSort vSort)
    | .unsupported r, _ => .unsupported s!"map key type: {r}"
    | _, .unsupported r => .unsupported s!"map value type: {r}"
  | .set elemBt =>
    -- CN uses SMT sets (solver.ml:415)
    match baseTypeToSort elemBt with
    | .ok elemSort => .ok (Term.appT (Term.symbolT "Set") elemSort)
    | .unsupported r => .unsupported s!"set element type: {r}"
  | .datatype dtTag =>
    match dtTag.name with
    | some name => .unsupported s!"datatype {name}"
    | none => .unsupported s!"datatype (id={dtTag.id})"

/-! ## Translation to Smt.Term -/

/-- Result of translation: either success or unsupported construct -/
inductive TranslateResult where
  | ok (tm : Smt.Term)
  | unsupported (reason : String)
  deriving Inhabited

/-! ## BitVec Literal Generation

SMT-LIB2 BitVec literals can be written as:
- `(_ bvN W)` - decimal value N of width W bits
- `#xHHHH` - hexadecimal (width must be multiple of 4)
- `#bBBBB` - binary

CN uses the indexed identifier notation: `(_ bvN W)`.
Corresponds to: simple_smt.ml bv_nat function
-/

/-- Generate a BitVec literal in SMT-LIB format: (_ bvN W)
    For negative numbers, we convert to two's complement representation. -/
def mkBitVecLiteral (width : Nat) (value : Int) : Smt.Term :=
  -- Convert negative numbers to two's complement unsigned representation
  let unsignedVal : Nat :=
    if value < 0 then
      let modulus := Nat.pow 2 width
      (modulus - ((-value).toNat % modulus)) % modulus
    else
      value.toNat % (Nat.pow 2 width)
  Term.mkApp2 (Term.symbolT "_")
              (Term.symbolT s!"bv{unsignedVal}")
              (Term.literalT (toString width))

/-! ## Integer Bounds for Representability -/

/-- Get bit width for an integer base kind -/
def intBaseKindWidthSmt (kind : Core.IntBaseKind) : Nat :=
  match kind with
  | .ichar => 8
  | .short => 16
  | .int_ => 32
  | .long => 64
  | .longLong => 64
  | .intN n => n
  | .intLeastN n => n
  | .intFastN n => n
  | .intmax => 64
  | .intptr => 64

/-- Get bounds for an integer type (lo, hi) where lo <= val < hi for representability -/
def integerTypeBounds (ity : Core.IntegerType) : Option (Int × Int) :=
  match ity with
  | .signed kind =>
    let width := intBaseKindWidthSmt kind
    let half := Int.pow 2 (width - 1)
    some (-half, half)
  | .unsigned kind =>
    let width := intBaseKindWidthSmt kind
    let max := Int.pow 2 width
    some (0, max)
  | .char => some (-128, 128)  -- Assuming signed char
  | .bool => some (0, 2)
  | .size_t => some (0, Int.pow 2 64)
  | .ptrdiff_t => some (-(Int.pow 2 63), Int.pow 2 63)
  | .wchar_t => some (-(Int.pow 2 31), Int.pow 2 31)
  | .wint_t => some (-(Int.pow 2 31), Int.pow 2 31)
  | .ptraddr_t => some (0, Int.pow 2 64)
  | .enum _ => some (-(Int.pow 2 31), Int.pow 2 31)

/-! ## Constant Conversion -/

/-- Convert a Const to Smt.Term.
    For Bits constants, generates proper BitVec literals using indexed notation.
    Corresponds to: CN's handling of Const.Bits in solver.ml -/
def constToTerm : Const → TranslateResult
  | .z n =>
    .ok (Term.literalT (toString n))
  | .bits _sign width n =>
    .ok (mkBitVecLiteral width n)  -- Proper BitVec literal
  | .bool true => .ok (Term.symbolT "true")
  | .bool false => .ok (Term.symbolT "false")
  | .null => .ok (Term.symbolT "NULL")  -- CN_Pointer.con_null (solver.ml:542)
  | .unit => .ok (Term.literalT "cn_tuple_0")  -- Unit value = empty tuple constructor (solver.ml:550)
  | .q num denom => .ok (Term.mkApp2 (Term.symbolT "/") (Term.literalT (toString num)) (Term.literalT (toString denom)))
  | .allocId id => .ok (Term.literalT (toString id))
  | .pointer p =>  -- CN_Pointer.con_aia (solver.ml:545-547)
    .ok (Term.mkApp2 (Term.symbolT "AiA")
      (Term.literalT (toString p.allocId))
      (mkBitVecLiteral 64 p.addr))
  | .memByte m =>
    -- CN_MemByte.con ~alloc_id ~value (solver.ml:537-543)
    -- AiV(alloc_id: cn_option Int, value: BitVec 8)
    let allocIdTerm := match m.allocId with
      | none =>
        -- (as cn_none (cn_option Int)) — typed none (solver.ml:540)
        Term.literalT "(as cn_none (cn_option Int))"
      | some z =>
        -- (cn_some z) (solver.ml:541)
        Term.appT (Term.symbolT "cn_some") (Term.literalT (toString z))
    let valueTerm := mkBitVecLiteral 8 m.value
    .ok (Term.mkApp2 (Term.symbolT "AiV") allocIdTerm valueTerm)
  | .ctypeConst _ =>
    -- CN encodes CType constants via a CTypeMap assigning each ctype an Int (solver.ml:552)
    -- We don't maintain such a map; mark as unsupported for now
    .unsupported "ctypeConst in SMT query (no CTypeMap)"
  | .default _ =>
    -- CN encodes Default(t) as cn_val(cn_none(translate_base_type t)) (solver.ml:553)
    .unsupported "default value in SMT query"

/-- Check if a base type is a bitvector type -/
def isBitsType : BaseType → Bool
  | .bits _ _ => true
  | _ => false

/-- Check if a base type is signed bits (for bitvector operation dispatch) -/
def isSignedBits : BaseType → Bool
  | .bits .signed _ => true
  | _ => false

/-- Check if a term is an integer literal -/
def isIntLiteral (tm : Smt.Term) : Option Int :=
  match tm with
  | .literalT s =>
    -- Try to parse as integer
    match s.toInt? with
    | some n => some n
    | none => none
  | _ => none

/-- Convert an integer to a BitVec literal for use in comparisons.
    Used when comparing integer constants with BitVec values. -/
def intToBitVecTerm (n : Int) (width : Nat) : Smt.Term :=
  mkBitVecLiteral width n

/-- Convert a UnOp application to Smt.Term.
    Type-aware: dispatches to bitvector operations for Bits types. -/
def unOpToTerm (op : UnOp) (argBt : BaseType) (arg : Smt.Term) : TranslateResult :=
  let useBv := isBitsType argBt
  match op with
  | .not => .ok (Term.appT (Term.symbolT "not") arg)
  | .negate => if useBv then .ok (Term.appT (Term.symbolT "bvneg") arg)
               else .ok (Term.appT (Term.symbolT "-") arg)
  | .bwCompl => if useBv then .ok (Term.appT (Term.symbolT "bvnot") arg)
                else .unsupported "bwCompl requires Bits type"
  | .bwClzNoSMT => .unsupported "bwClzNoSMT"
  | .bwCtzNoSMT => .unsupported "bwCtzNoSMT"
  | .bwFfsNoSMT => .unsupported "bwFfsNoSMT"
  | .bwFlsNoSMT => .unsupported "bwFlsNoSMT"

/-- Convert a BinOp application to Smt.Term.
    Type-aware: dispatches to bitvector operations for Bits types.
    Both operands are expected to have matching types (enforced by Pexpr.lean).
    Corresponds to: CN's solver.ml lines 688-730 for arithmetic, 752-765 for comparisons
    Audited: 2026-02-18 -/
def binOpToTerm (op : BinOp) (lBt rBt : BaseType) (l r : Smt.Term) : TranslateResult :=
  -- Pointer comparisons: extract addresses and compare as bitvectors
  -- Must be handled before the type consistency check since loc is now an ADT sort.
  -- Corresponds to: solver.ml lines 771-776
  match op with
  | .ltPointer =>
    .ok (Term.mkApp2 (Term.symbolT "bvult")
      (Term.appT (Term.symbolT "addr_of") l)
      (Term.appT (Term.symbolT "addr_of") r))
  | .lePointer =>
    .ok (Term.mkApp2 (Term.symbolT "bvule")
      (Term.appT (Term.symbolT "addr_of") l)
      (Term.appT (Term.symbolT "addr_of") r))
  | _ =>
  -- Type consistency check: both operands should have matching types
  -- If they don't, the type checker has a bug - don't mask it
  if isBitsType lBt != isBitsType rBt then
    .unsupported s!"Type mismatch in binop {repr op}: left={repr lBt}, right={repr rBt}"
  else
  -- Both operands should have matching types after Pexpr type fixup
  -- Use left operand's type to determine if we need bitvector ops
  let useBv := isBitsType lBt
  let signed := isSignedBits lBt  -- Only meaningful when useBv = true
  let mkBinApp (sym : String) := .ok (Term.mkApp2 (Term.symbolT sym) l r)
  -- *NoSMT operations: translate as uninterpreted functions, not actual arithmetic.
  -- Corresponds to: solver.ml lines 679-682 (uninterp_same_type) and CN_Names.mul/div/exp/rem/mod'
  -- (solver.ml:32-40). The UF name is "<op>_uf_<bt_suffix>" where bt_suffix comes from BT.pp.
  let mkUninterpApp (opPrefix : String) (bt : BaseType) :=
    match baseTypeUfSuffix bt with
    | some suffix => mkBinApp s!"{opPrefix}_uf_{suffix}"
    | none => .unsupported s!"{opPrefix}NoSMT: unsupported base type {repr bt}"
  match op with
  -- Arithmetic operations
  | .add => if useBv then mkBinApp "bvadd" else mkBinApp "+"
  | .sub => if useBv then mkBinApp "bvsub" else mkBinApp "-"
  | .mul => if useBv then mkBinApp "bvmul" else mkBinApp "*"
  | .mulNoSMT => mkUninterpApp "mul" lBt  -- solver.ml:703
  | .div =>
    if useBv then
      if signed then mkBinApp "bvsdiv" else mkBinApp "bvudiv"
    else mkBinApp "div"
  | .divNoSMT => mkUninterpApp "div" lBt  -- solver.ml:710
  | .rem =>
    if useBv then
      if signed then mkBinApp "bvsrem" else mkBinApp "bvurem"
    else mkBinApp "mod"
  | .remNoSMT => mkUninterpApp "rem" lBt  -- solver.ml:723
  | .mod_ =>
    if useBv then
      if signed then mkBinApp "bvsmod" else mkBinApp "bvurem"
    else mkBinApp "mod"
  | .modNoSMT => mkUninterpApp "mod" lBt  -- solver.ml:730
  -- Comparison operations
  | .lt =>
    if useBv then
      if signed then mkBinApp "bvslt" else mkBinApp "bvult"
    else mkBinApp "<"
  | .le =>
    if useBv then
      if signed then mkBinApp "bvsle" else mkBinApp "bvule"
    else mkBinApp "<="
  | .eq => mkBinApp "="  -- Equality is the same for all types
  -- Logical operations (type-independent)
  | .and_ => mkBinApp "and"
  | .or_ => mkBinApp "or"
  | .implies => mkBinApp "=>"
  -- Pointer comparisons handled above (before type consistency check)
  | .ltPointer | .lePointer => .unsupported "unreachable: pointer comparisons handled above"
  -- Bitwise operations (require bitvector types)
  | .bwXor => if useBv then mkBinApp "bvxor" else .unsupported "bwXor requires Bits type"
  | .bwAnd => if useBv then mkBinApp "bvand" else .unsupported "bwAnd requires Bits type"
  | .bwOr => if useBv then mkBinApp "bvor" else .unsupported "bwOr requires Bits type"
  | .shiftLeft => if useBv then mkBinApp "bvshl" else .unsupported "shiftLeft requires Bits type"
  | .shiftRight =>
    if useBv then
      if signed then mkBinApp "bvashr" else mkBinApp "bvlshr"
    else .unsupported "shiftRight requires Bits type"
  -- Exp: CN handles this specially (solver.ml:711-715) by evaluating constant exponents
  -- at translation time. We don't do that; mark unsupported for now.
  | .exp => .unsupported "exp (only constant exponents supported in CN)"
  | .expNoSMT => mkUninterpApp "exp" lBt  -- solver.ml:716
  -- Min/Max: CN translates as ite (solver.ml:767-769)
  -- NOTE: this duplicates terms, matching CN's approach
  | .min =>
    let leOp := if useBv then (if signed then "bvsle" else "bvule") else "<="
    .ok (Term.mkApp3 (Term.symbolT "ite") (Term.mkApp2 (Term.symbolT leOp) l r) l r)
  | .max =>
    let geOp := if useBv then (if signed then "bvsge" else "bvuge") else ">="
    .ok (Term.mkApp3 (Term.symbolT "ite") (Term.mkApp2 (Term.symbolT geOp) l r) l r)
  -- Set operations: CVC5 set operations (solver.ml:777-781, simple_smt.ml:359-391)
  | .setUnion => mkBinApp "set.union"
  | .setIntersection => mkBinApp "set.inter"
  | .setDifference => mkBinApp "set.minus"
  | .setMember => mkBinApp "set.member"
  | .subset => mkBinApp "set.subset"

/-- Compute sizeof for an integer type.
    Extracted from the .sizeOf case for reuse in arrayShift. -/
def sizeOfIntTypeNat : IntegerType → Option Nat
  | .bool => some 1
  | .char => some 1
  | .signed .ichar | .unsigned .ichar => some 1
  | .signed .short | .unsigned .short => some 2
  | .signed .int_ | .unsigned .int_ => some 4
  | .signed .long | .unsigned .long => some 8
  | .signed .longLong | .unsigned .longLong => some 8
  | .signed .intptr | .unsigned .intptr => some 8
  | .size_t | .ptrdiff_t | .ptraddr_t => some 8
  | .wchar_t | .wint_t => some 4
  | .enum _ => some 4
  | _ => none

/-- Compute sizeof for a C type as a Nat.
    Corresponds to: Memory.size_of_ctype in CN's solver.ml:866
    With TypeEnv, can also compute struct sizes. -/
def sizeOfCtypeNat (env : Option TypeEnv := none) : CerbLean.Core.Ctype_ → Option Nat
  | .void => some 0
  | .basic (.integer ity) => sizeOfIntTypeNat ity
  | .basic (.floating (.realFloating .float)) => some 4
  | .basic (.floating (.realFloating .double)) => some 8
  | .basic (.floating (.realFloating .longDouble)) => some 16
  | .pointer _ _ => some 8
  | .struct_ tag =>
    match env with
    | some e => (sizeof e { ty := Ctype_.struct_ tag }).toOption
    | none => none
  | _ => none

mutual

/-- Convert a CN Term to Smt.Term.
    Type information is obtained from AnnotTerm wrappers during recursion.
    The `env` parameter provides TypeEnv for struct layout info (memberShift, offsetOf, sizeOf). -/
partial def termToSmtTerm (env : Option TypeEnv) : Types.Term → TranslateResult
  | .const c => constToTerm c
  | .sym s => .ok (Term.symbolT (symToSmtName s))
  | .unop op arg =>
    -- Pass the operand's type to unOpToTerm
    match annotTermToSmtTerm env arg with
    | .ok argTm => unOpToTerm op arg.bt argTm
    | .unsupported r => .unsupported r
  | .binop op l r =>
    -- CN's arith_binop (indexTerms.ml:597) asserts BT.equal for both operands.
    -- Types should match after the type checker.
    match annotTermToSmtTerm env l, annotTermToSmtTerm env r with
    | .ok lTm, .ok rTm =>
      binOpToTerm op l.bt r.bt lTm rTm
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .ite cond thenB elseB =>
    match annotTermToSmtTerm env cond, annotTermToSmtTerm env thenB, annotTermToSmtTerm env elseB with
    | .ok c, .ok t, .ok e => .ok (Term.mkApp3 (Term.symbolT "ite") c t e)
    | .unsupported r, _, _ => .unsupported r
    | _, .unsupported r, _ => .unsupported r
    | _, _, .unsupported r => .unsupported r
  | .eachI lo (s, bt) hi body =>
    -- Unroll EachI to conjunction: body[s/lo] && body[s/lo+1] && ... && body[s/hi]
    -- If lo > hi, result is true.
    -- Corresponds to: solver.ml:784-796
    if lo > hi then
      .ok (Term.symbolT "true")
    else
      -- Create a constant term for the given integer value at the appropriate type
      -- Corresponds to: num_lit_ in indexTerms.ml:478-484
      let mkNumLit (i : Int) : AnnotTerm :=
        let c := match bt with
          | .bits sign width => Term.const (.bits sign width i)
          | _ => Term.const (.z i)
        AnnotTerm.mk c bt body.loc
      -- Unroll: substitute each value and translate, building conjunction
      let rec aux (i : Int) : TranslateResult :=
        let σ := Types.Subst.single s (mkNumLit i)
        let substituted := body.subst σ
        match annotTermToSmtTerm env substituted with
        | .unsupported r => .unsupported r
        | .ok t1 =>
          if i == hi then .ok t1
          else
            match aux (i + 1) with
            | .unsupported r => .unsupported r
            | .ok rest => .ok (Term.mkApp2 (Term.symbolT "and") t1 rest)
      aux lo
  | .let_ var binding body =>
    let name := symToSmtName var
    match annotTermToSmtTerm env binding, annotTermToSmtTerm env body with
    | .ok b, .ok bd => .ok (Term.letT name b bd)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .arrayShift base ct index =>
    -- ptr_shift(base, bvmul(el_size, index), NULL)
    -- Corresponds to: solver.ml lines 865-871
    -- Index is already uintptr_bt (Bits Unsigned 64) from type checker cast
    match annotTermToSmtTerm env base, annotTermToSmtTerm env index with
    | .ok b, .ok i =>
      match sizeOfCtypeNat env ct.ty with
      | some elSize =>
        let sizeBv := mkBitVecLiteral 64 elSize
        let offset := Term.mkApp2 (Term.symbolT "bvmul") sizeBv i
        .ok (Term.mkApp3 (Term.symbolT "ptr_shift") b offset (Term.symbolT "NULL"))
      | none => .unsupported s!"arrayShift element size: {repr ct.ty}"
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .aligned ptr align =>
    -- Extract address, check divisibility with bitvector unsigned remainder
    -- Corresponds to: solver.ml lines 887-890 (addr_ + divisible_)
    match annotTermToSmtTerm env ptr, annotTermToSmtTerm env align with
    | .ok p, .ok a =>
      let addrExpr := Term.appT (Term.symbolT "addr_of") p
      let zero64 := mkBitVecLiteral 64 0
      let remainder := Term.mkApp2 (Term.symbolT "bvurem") addrExpr a
      .ok (Term.mkApp2 (Term.symbolT "=") remainder zero64)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .representable ct val =>
    -- representable(ct, val): CN's value_check `Representable mode (indexTerms.ml:959-1010)
    -- Dispatch on C type, matching CN's aux function:
    --   Void/Byte → true
    --   Integer → range check (in_z_range)
    --   Pointer → true (value_check_pointer `Representable, indexTerms.ml:936)
    --   Struct → recursive per-field (not yet implemented)
    --   Array → recursive per-element (not yet implemented)
    match ct.ty with
    | .void | .byte => .ok (Term.symbolT "true")
    | .basic (.integer ity) =>
      -- For BitVec values, representability is trivially true (bounded by type width)
      if isBitsType val.bt then
        .ok (Term.symbolT "true")
      else
        -- For unbounded integers, generate range constraint
        match annotTermToSmtTerm env val with
        | .unsupported r => .unsupported r
        | .ok valTm =>
          let bounds := integerTypeBounds ity
          match bounds with
          | some (lo, hi) =>
            let loTm := Term.literalT (toString lo)
            let hiTm := Term.literalT (toString hi)
            let loCond := Term.mkApp2 (Term.symbolT "<=") loTm valTm
            let hiCond := Term.mkApp2 (Term.symbolT "<") valTm hiTm
            .ok (Term.mkApp2 (Term.symbolT "and") loCond hiCond)
          | none => .unsupported s!"representable: no bounds for {repr ity}"
    | .pointer _ _ =>
      -- CN: value_check_pointer `Representable returns bool_ true (indexTerms.ml:936)
      .ok (Term.symbolT "true")
    | _ => .unsupported s!"representable for {repr ct.ty}"
  | .good ct _val =>
    -- good(ct, val) checks val is representable in ct - needs proper handling
    .unsupported s!"good (type check for {repr ct.ty})"
  | .wrapI _intType val =>
    -- wrapI wraps integer value to representation type (modular arithmetic)
    -- Corresponds to: wrapI in CN's indexTerms.ml
    -- For bitvec SMT sorts, modular wrapping is enforced by the sort itself,
    -- so this is identity. If we ever use unbounded integer sorts, this would
    -- need explicit modular arithmetic (bvmod or similar).
    match annotTermToSmtTerm env val with
    | .unsupported r => .unsupported r
    | .ok valTm => .ok valTm
  | .cast targetType val =>
    -- cast changes type between CN base types
    -- Corresponds to: cast_ in CN's indexTerms.ml
    match annotTermToSmtTerm env val with
    | .unsupported r => .unsupported r
    | .ok valTm =>
      let sourceBt := val.bt
      match sourceBt, targetType with
      | .bits sign sw, .bits _ tw =>
        if sw == tw then .ok valTm  -- Same width: identity
        else if sw < tw then
          -- Extend: use sign_extend for signed, zero_extend for unsigned
          -- CN solver.ml uses sign_extend for signed, zero_extend for unsigned
          let extOp := if sign == .signed then "sign_extend" else "zero_extend"
          let ext := Term.mkApp2 (Term.symbolT "_") (Term.symbolT extOp) (Term.literalT (toString (tw - sw)))
          .ok (Term.appT ext valTm)
        else
          -- Truncate: use extract (indexed identifier with two args: high, low)
          let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract") (Term.literalT (toString (tw - 1))) (Term.literalT "0")
          .ok (Term.appT extract valTm)
      | .integer, .bits _ tw =>
        -- Int → BitVec: use int2bv (indexed identifier)
        -- Use literalT because Smt library's appToList doesn't special-case int2bv
        let int2bv := Term.literalT s!"(_ int2bv {tw})"
        .ok (Term.appT int2bv valTm)
      | .loc, .bits _ tw =>
        -- Loc → BitVec: extract address via addr_of, then possibly resize
        -- Corresponds to: solver.ml lines 965-972
        let addr := Term.appT (Term.symbolT "addr_of") valTm
        if tw == 64 then .ok addr  -- Already uintptr_bt width
        else if tw < 64 then
          -- Truncate: extract [tw-1:0]
          let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract")
            (Term.literalT (toString (tw - 1))) (Term.literalT "0")
          .ok (Term.appT extract addr)
        else
          -- Extend: zero_extend to wider width
          let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend")
            (Term.literalT (toString (tw - 64)))
          .ok (Term.appT zeroExt addr)
      | .loc, .allocId =>
        -- Loc → AllocId: extract allocation ID
        -- Corresponds to: solver.ml line 973-974
        .ok (Term.mkApp2 (Term.symbolT "alloc_id_of") valTm (Term.literalT "0"))
      | .bits _ _, .integer =>
        -- BitVec → Int: use bv2int
        .ok (Term.appT (Term.symbolT "bv2int") valTm)
      | .bits _ sw, .loc =>
        -- BitVec → Loc: use bits_to_ptr with default alloc_id=0
        -- Corresponds to: solver.ml lines 957-964
        let castBits :=
          if sw == 64 then valTm
          else if sw < 64 then
            -- Extend to 64 bits for pointer width
            let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend")
              (Term.literalT (toString (64 - sw)))
            Term.appT zeroExt valTm
          else
            -- Truncate to 64 bits
            let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract")
              (Term.literalT "63") (Term.literalT "0")
            Term.appT extract valTm
        .ok (Term.mkApp2 (Term.symbolT "bits_to_ptr") castBits (Term.literalT "0"))
      | .memByte, .bits _ tw =>
        -- MemByte → Bits: extract value field, then possibly resize
        -- Corresponds to: solver.ml lines 975-982
        let valueTm := Term.appT (Term.symbolT "value") valTm
        if tw == 8 then .ok valueTm
        else if tw > 8 then
          let zeroExt := Term.mkApp2 (Term.symbolT "_") (Term.symbolT "zero_extend")
            (Term.literalT (toString (tw - 8)))
          .ok (Term.appT zeroExt valueTm)
        else
          let extract := Term.mkApp3 (Term.symbolT "_") (Term.symbolT "extract")
            (Term.literalT (toString (tw - 1))) (Term.literalT "0")
          .ok (Term.appT extract valueTm)
      | .memByte, .option .allocId =>
        -- MemByte → Option AllocId: extract alloc_id field
        -- Corresponds to: solver.ml line 983
        .ok (Term.appT (Term.symbolT "alloc_id") valTm)
      | .real, .integer =>
        -- Real → Int: to_int (solver.ml:984)
        .ok (Term.appT (Term.symbolT "to_int") valTm)
      | .integer, .real =>
        -- Int → Real: to_real (solver.ml:985)
        .ok (Term.appT (Term.symbolT "to_real") valTm)
      | _, _ =>
        .unsupported s!"cast from {repr sourceBt} to {repr targetType}"
  | .copyAllocId addr loc =>
    -- copy_alloc_id(loc_ptr, addr_bitvec, NULL)
    -- Note: `loc` is the pointer to copy alloc_id FROM, `addr` is the new address
    -- Corresponds to: solver.ml lines 872-876
    match annotTermToSmtTerm env addr, annotTermToSmtTerm env loc with
    | .ok addrTm, .ok locTm =>
      .ok (Term.mkApp3 (Term.symbolT "copy_alloc_id") locTm addrTm (Term.symbolT "NULL"))
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .hasAllocId ptr =>
    -- ((_ is AiA) ptr) — tests if pointer has allocation ID (is non-null)
    -- Corresponds to: solver.ml line 877
    match annotTermToSmtTerm env ptr with
    | .ok p =>
      let isAiA := Term.literalT "(_ is AiA)"
      .ok (Term.appT isAiA p)
    | .unsupported r => .unsupported r
  | .sizeOf ct =>
    -- sizeOf(ctype) as a concrete integer
    -- With TypeEnv, can also compute struct sizes
    match sizeOfCtypeNat env ct.ty with
    | some n => .ok (Term.literalT (toString n))
    | none => .unsupported s!"sizeOf ({repr ct.ty})"
  | .offsetOf tag member =>
    -- Compute offset as BitVec 64 literal from struct layout
    -- Corresponds to: solver.ml lines 828-831
    let tagStr := tag.name.getD "?"
    match env with
    | none => .unsupported s!"offsetOf ({tagStr}, {member.name}): no TypeEnv"
    | some e =>
      match e.lookupTag tag with
      | some (.struct_ members _) =>
        match structOffsets e members with
        | .error err => .unsupported s!"offsetOf: structOffsets failed: {err}"
        | .ok offsets =>
        match offsets.find? (·.1 == member) with
        | some (_, offset) => .ok (mkBitVecLiteral 64 offset)
        | none => .unsupported s!"offsetOf: member {member.name} not found in struct {tagStr}"
      | some (.union_ _) => .ok (mkBitVecLiteral 64 0)  -- All union members at offset 0
      | _ => .unsupported s!"offsetOf: tag {tagStr} not found"
  | .memberShift ptr tag member =>
    -- ptr_shift(ptr, offset, NULL) where offset = offsetOf(tag, member)
    -- Corresponds to: solver.ml lines 860-864
    let tagStr := tag.name.getD "?"
    match annotTermToSmtTerm env ptr with
    | .unsupported r => .unsupported r
    | .ok p =>
      match env with
      | none => .unsupported s!"memberShift ({tagStr}, {member.name}): no TypeEnv"
      | some e =>
        match e.lookupTag tag with
        | some (.struct_ members _) =>
          match structOffsets e members with
          | .error err => .unsupported s!"memberShift: structOffsets failed: {err}"
          | .ok offsets =>
          match offsets.find? (·.1 == member) with
          | some (_, offset) =>
            let offsetBv := mkBitVecLiteral 64 offset
            .ok (Term.mkApp3 (Term.symbolT "ptr_shift") p offsetBv (Term.symbolT "NULL"))
          | none => .unsupported s!"memberShift: member {member.name} not found in struct {tagStr}"
        | some (.union_ _) =>
          -- Union members all at offset 0 — ptr_shift by 0
          let zeroBv := mkBitVecLiteral 64 0
          .ok (Term.mkApp3 (Term.symbolT "ptr_shift") p zeroBv (Term.symbolT "NULL"))
        | _ => .unsupported s!"memberShift: tag {tagStr} not found"
  | .cnSome val =>
    -- CN_Option.some (solver.ml:989): (cn_some val)
    match annotTermToSmtTerm env val with
    | .ok v => .ok (Term.appT (Term.symbolT "cn_some") v)
    | .unsupported r => .unsupported r
  | .getOpt opt =>
    -- CN_Option.val_ (solver.ml:991): (cn_val opt)
    match annotTermToSmtTerm env opt with
    | .ok o => .ok (Term.appT (Term.symbolT "cn_val") o)
    | .unsupported r => .unsupported r
  | .apply fn args =>
    let fnName := symToSmtName fn
    let rec buildApp (acc : Smt.Term) : List AnnotTerm → TranslateResult
      | [] => .ok acc
      | arg :: rest =>
        match annotTermToSmtTerm env arg with
        | .ok argTm => buildApp (Term.appT acc argTm) rest
        | .unsupported r => .unsupported r
    buildApp (Term.symbolT fnName) args
  | .tuple elems =>
    -- CN_Tuple.con (solver.ml:798): (cn_tuple_N elem1 ... elemN)
    let arity := elems.length
    if arity > maxTupleArity then
      .unsupported s!"tuple arity {arity} exceeds max {maxTupleArity}"
    else
      let conName := s!"cn_tuple_{arity}"
      let rec buildTupleApp (acc : Smt.Term) : List AnnotTerm → TranslateResult
        | [] => .ok acc
        | elem :: rest =>
          match annotTermToSmtTerm env elem with
          | .ok elemTm => buildTupleApp (Term.appT acc elemTm) rest
          | .unsupported r => .unsupported r
      buildTupleApp (Term.symbolT conName) elems
  | .nthTuple n tup =>
    -- CN_Tuple.get (solver.ml:801): (cn_get_N_of_A tuple)
    -- First try static resolution if scrutinee is a literal tuple
    match tup.term with
    | .tuple elems =>
      if h : n < elems.length then
        annotTermToSmtTerm env (elems.get ⟨n, h⟩)
      else
        .unsupported s!"nthTuple index {n} out of bounds for tuple of size {elems.length}"
    | _ =>
      -- Dynamic resolution: use CN_Tuple selector function
      -- Need to know the arity from the type
      match tup.bt with
      | .tuple bts =>
        let arity := bts.length
        let selector := s!"cn_get_{n}_of_{arity}"
        match annotTermToSmtTerm env tup with
        | .ok tupTm => .ok (Term.appT (Term.symbolT selector) tupTm)
        | .unsupported r => .unsupported r
      | _ => .unsupported s!"nthTuple on non-tuple type ({repr tup.bt})"
  -- Struct construction: apply constructor to member values
  -- Corresponds to: solver.ml:805-808 (IT.Struct)
  | .struct_ tag members =>
    let conName := structSmtName tag
    -- Translate each member value
    -- Translate all member values, collecting results
    let (memberStrs, unsupErr) := members.foldl (init := ([], Option.none))
      fun (acc, err) (_, t) =>
        match err with
        | some _ => (acc, err)  -- Already hit an error, skip rest
        | none =>
          match annotTermToSmtTerm env t with
          | .ok term => (acc ++ [toString (Term.toSexp term)], none)
          | .unsupported r => (acc, some r)
    match unsupErr with
    | some r => .unsupported s!"struct member: {r}"
    | none =>
      let argsStr := String.intercalate " " memberStrs
      .ok (Term.literalT s!"({conName} {argsStr})")
  -- Struct member access: apply selector function
  -- Corresponds to: solver.ml:809-810 (IT.StructMember)
  | .structMember obj member =>
    match annotTermToSmtTerm env obj with
    | .ok objTerm =>
      let selName := structFieldName member
      let objStr := toString (Term.toSexp objTerm)
      .ok (Term.literalT s!"({selName} {objStr})")
    | .unsupported r => .unsupported s!"structMember object: {r}"
  -- Struct update: reconstruct with one field changed
  -- Corresponds to: solver.ml:811-827 (IT.StructUpdate)
  -- CN reconstructs the entire struct, copying all fields except the updated one.
  -- We need TypeEnv to enumerate all fields.
  | .structUpdate obj member value =>
    match env with
    | none => .unsupported "structUpdate requires TypeEnv"
    | some e =>
      -- Get the struct tag from the object's type
      match obj.bt with
      | .struct_ tag =>
        match e.lookupTag tag with
        | none => .unsupported s!"structUpdate: unknown struct tag {tag.name.getD "?"}"
        | some (.struct_ members _) =>
          -- For each member: if it's the updated one, use value; otherwise project from obj
          match annotTermToSmtTerm env obj, annotTermToSmtTerm env value with
          | .ok objTerm, .ok valTerm =>
            let objStr := toString (Term.toSexp objTerm)
            let valStr := toString (Term.toSexp valTerm)
            let conName := structSmtName tag
            let fieldStrs := members.map fun m =>
              if m.name == member then valStr
              else s!"({structFieldName m.name} {objStr})"
            let argsStr := String.intercalate " " fieldStrs
            .ok (Term.literalT s!"({conName} {argsStr})")
          | .unsupported r, _ => .unsupported s!"structUpdate object: {r}"
          | _, .unsupported r => .unsupported s!"structUpdate value: {r}"
        | some (.union_ _) => .unsupported "structUpdate on union"
      | _ => .unsupported s!"structUpdate: object type is not struct ({repr obj.bt})"
  | .record _ => .unsupported "record"
  | .recordMember _ _ => .unsupported "recordMember"
  | .recordUpdate _ _ _ => .unsupported "recordUpdate"
  | .constructor constr args =>
    -- Datatype constructor application (solver.ml:916-919)
    let conName := symToSmtName constr
    let rec buildConApp (acc : Smt.Term) : List (Identifier × AnnotTerm) → TranslateResult
      | [] => .ok acc
      | (_, arg) :: rest =>
        match annotTermToSmtTerm env arg with
        | .ok argTm => buildConApp (Term.appT acc argTm) rest
        | .unsupported r => .unsupported r
    buildConApp (Term.symbolT conName) args
  | .nil bt =>
    -- CN_List.nil (solver.ml:879): (as cn_nil (cn_list <elem_sort>))
    match baseTypeToSort bt with
    | .ok elemSort =>
      let listSort := Term.appT (Term.symbolT "cn_list") elemSort
      .ok (Term.mkApp2 (Term.symbolT "as") (Term.symbolT "cn_nil") listSort)
    | .unsupported r => .unsupported s!"nil element type: {r}"
  | .cons hd tl =>
    -- CN_List.cons (solver.ml:880): (cn_cons head tail)
    match annotTermToSmtTerm env hd, annotTermToSmtTerm env tl with
    | .ok h, .ok t => .ok (Term.mkApp2 (Term.symbolT "cn_cons") h t)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .head lst =>
    -- CN_List.head (solver.ml:881): (cn_head list)
    match annotTermToSmtTerm env lst with
    | .ok l => .ok (Term.appT (Term.symbolT "cn_head") l)
    | .unsupported r => .unsupported r
  | .tail lst =>
    -- CN_List.tail (solver.ml:882): (cn_tail list)
    match annotTermToSmtTerm env lst with
    | .ok l => .ok (Term.appT (Term.symbolT "cn_tail") l)
    | .unsupported r => .unsupported r
  | .mapConst keyBt val =>
    -- SMT array constant (solver.ml:892-903): ((as const (Array K V)) val)
    match baseTypeToSort keyBt with
    | .unsupported r => .unsupported s!"mapConst key type: {r}"
    | .ok kSort =>
      match baseTypeToSort val.bt with
      | .unsupported r => .unsupported s!"mapConst value type: {r}"
      | .ok vSort =>
        match annotTermToSmtTerm env val with
        | .unsupported r => .unsupported r
        | .ok valTm =>
          let arrSort := Term.mkApp2 (Term.symbolT "Array") kSort vSort
          let constFn := Term.mkApp2 (Term.symbolT "as") (Term.symbolT "const") arrSort
          .ok (Term.appT constFn valTm)
  | .mapSet mp key val =>
    -- SMT array store (solver.ml:904-905): (store map key val)
    match annotTermToSmtTerm env mp, annotTermToSmtTerm env key, annotTermToSmtTerm env val with
    | .ok m, .ok k, .ok v => .ok (Term.mkApp3 (Term.symbolT "store") m k v)
    | .unsupported r, _, _ => .unsupported r
    | _, .unsupported r, _ => .unsupported r
    | _, _, .unsupported r => .unsupported r
  | .mapGet mp key =>
    -- SMT array select (solver.ml:906): (select map key)
    match annotTermToSmtTerm env mp, annotTermToSmtTerm env key with
    | .ok m, .ok k => .ok (Term.mkApp2 (Term.symbolT "select") m k)
    | .unsupported r, _ => .unsupported r
    | _, .unsupported r => .unsupported r
  | .mapDef _ _ => .unsupported "mapDef (CN also fails on this: solver.ml:907)"
  | .match_ scrutinee cases =>
    -- Support match patterns from CN.
    -- For tuple destructuring, we create SMT let-bindings that tie pattern
    -- variables to the corresponding scrutinee components.
    -- Corresponds to: match handling in CN's solver translation
    match cases with
    | [] => .unsupported "match with no cases"
    | (pat, body) :: rest =>
      -- Try to create let-bindings from pattern + scrutinee
      match extractPatternBindings env pat scrutinee with
      | .error r => .unsupported s!"match pattern bindings: {r}"
      | .ok bindings =>
        let bodyTm := annotTermToSmtTerm env body
        match bodyTm with
        | .unsupported r => .unsupported r
        | .ok bodySmtTm =>
          if bindings.isEmpty then
            -- No bindings to create
            if rest.isEmpty then .ok bodySmtTm
            else if scrutinee.bt matches .bool then
              -- Boolean match: use if-then-else
              match rest with
              | [(_, body2)] =>
                match annotTermToSmtTerm env scrutinee, annotTermToSmtTerm env body2 with
                | .ok s, .ok b2 => .ok (Term.mkApp3 (Term.symbolT "ite") s bodySmtTm b2)
                | .unsupported r, _ => .unsupported r
                | _, .unsupported r => .unsupported r
              | _ => .unsupported s!"match on boolean with {rest.length + 1} cases (expected 2)"
            else .unsupported s!"match on non-boolean ({repr scrutinee.bt}) with {rest.length + 1} cases"
          else
            -- Create nested let-bindings for pattern variables
            let result := bindings.foldl (init := bodySmtTm) fun acc (name, valTm) =>
              Term.letT name valTm acc
            .ok result
  | .cnNone bt =>
    -- CN_Option.none (solver.ml:988): (as cn_none (cn_option <sort>))
    match baseTypeToSort bt with
    | .ok innerSort =>
      let optSort := Term.appT (Term.symbolT "cn_option") innerSort
      .ok (Term.mkApp2 (Term.symbolT "as") (Term.symbolT "cn_none") optSort)
    | .unsupported r => .unsupported s!"cnNone inner type: {r}"
  | .isSome opt =>
    -- CN_Option.is_some (solver.ml:990): (is-cn_some opt)
    match annotTermToSmtTerm env opt with
    | .ok o => .ok (Term.appT (Term.symbolT "is-cn_some") o)
    | .unsupported r => .unsupported r

/-- Convert an AnnotTerm to Smt.Term -/
partial def annotTermToSmtTerm (env : Option TypeEnv) (at_ : AnnotTerm) : TranslateResult :=
  termToSmtTerm env at_.term

/-- Extract pattern bindings from a match: pairs of (smt_name, scrutinee_component_term).
    For a tuple destructuring match, this creates let-bindings that tie
    pattern variables to the corresponding scrutinee components. -/
partial def extractPatternBindings (env : Option TypeEnv) (pat : Types.Pattern) (scrutinee : AnnotTerm)
    : Except String (List (String × Smt.Term)) :=
  match pat.pat with
  | .sym s =>
    -- Single variable pattern: bind to whole scrutinee
    match annotTermToSmtTerm env scrutinee with
    | .ok tm => .ok [(symToSmtName s, tm)]
    | .unsupported r => .error s!"pattern binding: {r}"
  | .constructor _ctor args =>
    -- Constructor pattern: handle tuple destructuring and wrappers like Specified(x)
    match scrutinee.term with
    | .tuple components =>
      -- Tuple destructuring: match up pattern args with tuple components
      let pairs := args.zip components
      let results := pairs.map fun ((_, subPat), component) =>
        extractPatternBindings env subPat component
      -- Collect all results, propagating any errors
      let collected := results.foldl (init := Except.ok ([] : List (String × Smt.Term))) fun acc r =>
        match acc, r with
        | .error e, _ => .error e
        | _, .error e => .error e
        | .ok ls, .ok rs => .ok (ls ++ rs)
      collected
    | _ =>
      -- Non-tuple scrutinee: for single-arg constructors (like Specified(x)),
      -- unwrap and bind the inner pattern to the scrutinee directly
      match args with
      | [(_, innerPat)] => extractPatternBindings env innerPat scrutinee
      | _ => .error s!"constructor pattern with {args.length} args on non-tuple scrutinee"
  | .wild => .ok []  -- Wildcard: no binding

end

/-- Convert a LogicalConstraint to Smt.Term -/
def constraintToSmtTerm (env : Option TypeEnv := none) : LogicalConstraint → TranslateResult
  | .t it => annotTermToSmtTerm env it
  | .forall_ (s, bt) body =>
    let name := symToSmtName s
    match baseTypeToSort bt with
    | .unsupported reason => .unsupported s!"forall bound variable type: {reason}"
    | .ok sort =>
      match annotTermToSmtTerm env body with
      | .ok b => .ok (Term.forallT name sort b)
      | .unsupported r => .unsupported r

/-! ## Free Symbol Collection with Types

We collect (Sym, BaseType) pairs to generate properly-typed SMT declarations.
CN uses actual SMT-LIB BitVec types for Bits, so we generate declarations like
`(declare-const v (_ BitVec 32))` instead of `(declare-const v Int)`.
-/

/-- A typed symbol for SMT generation -/
abbrev TypedSym := Sym × BaseType

mutual

/-- Collect free symbols with types from an AnnotTerm.
    Returns (Sym, BaseType) pairs where BaseType comes from the term's annotation. -/
partial def annotTermFreeTypedSyms (at_ : AnnotTerm) : List TypedSym :=
  match at_.term with
  | .sym s => [(s, at_.bt)]
  | .const _ => []
  | .unop _ arg => annotTermFreeTypedSyms arg
  | .binop _ l r => annotTermFreeTypedSyms l ++ annotTermFreeTypedSyms r
  | .ite c t e => annotTermFreeTypedSyms c ++ annotTermFreeTypedSyms t ++ annotTermFreeTypedSyms e
  | .eachI _ (s, _) _ body => (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .tuple elems => elems.flatMap annotTermFreeTypedSyms
  | .nthTuple _ tup => annotTermFreeTypedSyms tup
  | .struct_ _ members => members.flatMap (annotTermFreeTypedSyms ·.2)
  | .structMember obj _ => annotTermFreeTypedSyms obj
  | .structUpdate obj _ val => annotTermFreeTypedSyms obj ++ annotTermFreeTypedSyms val
  | .record members => members.flatMap (annotTermFreeTypedSyms ·.2)
  | .recordMember obj _ => annotTermFreeTypedSyms obj
  | .recordUpdate obj _ val => annotTermFreeTypedSyms obj ++ annotTermFreeTypedSyms val
  | .constructor _ args => args.flatMap (annotTermFreeTypedSyms ·.2)
  | .memberShift ptr _ _ => annotTermFreeTypedSyms ptr
  | .arrayShift base _ idx => annotTermFreeTypedSyms base ++ annotTermFreeTypedSyms idx
  | .copyAllocId addr loc => annotTermFreeTypedSyms addr ++ annotTermFreeTypedSyms loc
  | .hasAllocId ptr => annotTermFreeTypedSyms ptr
  | .sizeOf _ => []
  | .offsetOf _ _ => []
  | .nil _ => []
  | .cons h t => annotTermFreeTypedSyms h ++ annotTermFreeTypedSyms t
  | .head l => annotTermFreeTypedSyms l
  | .tail l => annotTermFreeTypedSyms l
  | .representable _ val => annotTermFreeTypedSyms val
  | .good _ val => annotTermFreeTypedSyms val
  | .aligned ptr align => annotTermFreeTypedSyms ptr ++ annotTermFreeTypedSyms align
  | .wrapI _ val => annotTermFreeTypedSyms val
  | .mapConst _ val => annotTermFreeTypedSyms val
  | .mapSet m k v => annotTermFreeTypedSyms m ++ annotTermFreeTypedSyms k ++ annotTermFreeTypedSyms v
  | .mapGet m k => annotTermFreeTypedSyms m ++ annotTermFreeTypedSyms k
  | .mapDef (s, _) body => (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .apply _ args => args.flatMap annotTermFreeTypedSyms
  | .let_ s binding body =>
    annotTermFreeTypedSyms binding ++ (annotTermFreeTypedSyms body).filter (·.1 != s)
  | .match_ scrut cases =>
    annotTermFreeTypedSyms scrut ++ cases.flatMap (annotTermFreeTypedSyms ·.2)
  | .cast _ val => annotTermFreeTypedSyms val
  | .cnNone _ => []
  | .cnSome val => annotTermFreeTypedSyms val
  | .isSome opt => annotTermFreeTypedSyms opt
  | .getOpt opt => annotTermFreeTypedSyms opt

end

/-- Collect free symbols with types from a LogicalConstraint -/
def constraintFreeTypedSyms : LogicalConstraint → List TypedSym
  | .t it => annotTermFreeTypedSyms it
  | .forall_ (s, _bt) body =>
    -- The bound variable has the given type, but we filter it out
    (annotTermFreeTypedSyms body).filter (·.1 != s)

/-- Deduplicate typed symbols, keeping the first occurrence of each symbol -/
def deduplicateTypedSyms (syms : List TypedSym) : List TypedSym :=
  syms.foldl (fun acc (s, bt) =>
    if acc.any (·.1 == s) then acc else acc ++ [(s, bt)]
  ) []

/-- Collect all free symbols with types from an obligation -/
def obligationFreeTypedSyms (ob : Obligation) : List TypedSym :=
  let assumptionSyms := ob.assumptions.flatMap constraintFreeTypedSyms
  let constraintSyms := constraintFreeTypedSyms ob.constraint
  deduplicateTypedSyms (assumptionSyms ++ constraintSyms)

/-- Legacy: Collect free symbols without types (for backwards compatibility) -/
def annotTermFreeSyms (at_ : AnnotTerm) : List Sym :=
  (annotTermFreeTypedSyms at_).map (·.1)

/-- Legacy: Collect free symbols from a constraint -/
def constraintFreeSyms (lc : LogicalConstraint) : List Sym :=
  (constraintFreeTypedSyms lc).map (·.1)

/-- Legacy: Collect all free symbols from an obligation -/
def obligationFreeSyms (ob : Obligation) : List Sym :=
  (obligationFreeTypedSyms ob).map (·.1)

/-! ## Query Building -/

/-- Build SMT commands for an obligation.
    Returns the commands and any unsupported constructs encountered.

    Uses proper SMT-LIB types: Bits symbols are declared with `(_ BitVec n)`,
    matching CN's approach in solver.ml.
    Corresponds to: CN's solver.ml translate_global_decls -/
def obligationToCommands (ob : Obligation) (env : Option TypeEnv := none)
    : List Command × List String :=
  let typedSyms := obligationFreeTypedSyms ob

  -- Generate declarations with proper SMT sorts (BitVec for Bits types)
  -- Collect errors for symbols with unsupported types
  let (decls, declErrors) := typedSyms.foldl (fun (cmds, errs) (s, bt) =>
    match baseTypeToSort bt with
    | .ok sort => (cmds ++ [Command.declare (symToSmtName s) sort], errs)
    | .unsupported reason => (cmds, errs ++ [s!"symbol {symToSmtName s}: {reason}"])
  ) ([], [])

  -- Translate assumptions
  let (assumptionTerms, assumptionErrors) := ob.assumptions.foldl
    (fun (terms, errs) lc =>
      match constraintToSmtTerm env lc with
      | .ok tm => (tm :: terms, errs)
      | .unsupported r =>
        -- Include the source constraint description in the error
        let lcDesc := match lc with
          | .t at_ => s!"bt={repr at_.bt}"
          | .forall_ _ _ => "forall"
        (terms, s!"{r} (from: {lcDesc})" :: errs))
    ([], [])

  -- No need for explicit range constraints - BitVec types handle this
  let allAssumptions := assumptionTerms.reverse

  -- Build conjunction of assumptions (or "true" if empty)
  let assumptionConj :=
    match allAssumptions with
    | [] => Term.symbolT "true"
    | [single] => single
    | first :: rest => rest.foldl (fun acc tm =>
        Term.mkApp2 (Term.symbolT "and") acc tm) first

  -- Translate goal
  let (goalTerm, goalErrors) :=
    match constraintToSmtTerm env ob.constraint with
    | .ok tm => (tm, [])
    | .unsupported r => (Term.symbolT "false", [r])

  let allErrors :=
    (declErrors.map (s!"[decl] " ++ ·)) ++
    (assumptionErrors.reverse.map (s!"[assumption] " ++ ·)) ++
    (goalErrors.map (s!"[goal] " ++ ·))

  -- Build implication: assumptions => goal
  let implication := Term.mkApp2 (Term.symbolT "=>") assumptionConj goalTerm

  -- Assert negation (checking if the implication can be falsified)
  let assertion := Command.assert (Term.appT (Term.symbolT "not") implication)

  let commands := decls ++ [assertion, Command.checkSat]

  (commands, allErrors)

/-- Convert obligation to SMT-LIB2 query string.
    Prepends the pointer datatype preamble before declarations. -/
def obligationToSmtLib2 (ob : Obligation) (env : Option TypeEnv := none)
    : String × List String :=
  let (cmds, errors) := obligationToCommands ob env
  let queryStr := Command.cmdsAsQuery cmds
  let structDecls := match env with
    | some e => generateStructPreamble e
    | none => ""
  let ufDecls := uninterpFunctionPreamble
  let withComment := s!"; Obligation: {ob.description}\n{solverBasicsPreamble}{ufDecls}{structDecls}{queryStr}"
  (withComment, errors)

/-- Serialize multiple obligations, each as a separate query -/
def obligationsToSmtLib2 (obs : List Obligation) (env : Option TypeEnv := none)
    : List (Obligation × String × List String) :=
  obs.map fun ob =>
    let (smt, errors) := obligationToSmtLib2 ob env
    (ob, smt, errors)

end CerbLean.CN.Verification.SmtLib
