/-
  CN Separation Logic Theorems
  Corresponds to: cn/coq/Reasoning/ResourceInference.v

  This module contains the key theorems for CN's separation logic:
  - frame_derived: The frame property for resource interpretation

  Audited: 2026-01-18 against cn/coq/Reasoning/ResourceInference.v
-/

import CerbLean.CN.Semantics.Interpretation
import Mathlib.Tactic

namespace CerbLean.CN.Semantics

open CerbLean.CN.Types

/-! ## Soundness

The main soundness theorem connects the two levels:
1. If resource inference is valid (syntactic level)
2. And the initial heap satisfies the interpretation of precondition resources
3. Then the final heap satisfies the interpretation of postcondition resources

This is CN's approach to soundness.
-/

/- TODO: Soundness theorem requires proper execution relation
   The statement below is incomplete - it needs:
   1. A proper execution relation connecting pre/post states
   2. Connection between ρPre and ρPost via execution
   3. Connection between hPre and hPost via execution

theorem cn_soundness
    (spec : FunctionSpec)
    (preCtx postCtx : Context)
    (hPre hPost : HeapFragment)
    (ρPre ρPost : Valuation)
    (hInferValid : SpecInferenceValid)
    (hInferSpec : hInferValid.spec = spec)
    (hInferPre : hInferValid.preCtx = preCtx)
    (hInferPost : hInferValid.postCtx = postCtx)
    (hPreSat : interpResources preCtx.resources ρPre hPre)
    (_hExec : True)  -- PLACEHOLDER: needs real execution relation
    : interpResources postCtx.resources ρPost hPost := by
  sorry
-/

/-! ## Frame Property

The frame property follows from how resource inference works:
resources not mentioned in the spec are preserved in the context,
so their interpretation is preserved in the heap.

This is a consequence of SimpleResourceInferenceStep.resourceBalance
-/

/-- Frame property (derived)

    The frame property follows from how resource inference works:
    resources not mentioned in the spec are preserved in the context,
    so their interpretation is preserved in the heap.

    This is a consequence of SimpleResourceInferenceStep.resourceBalance -/
theorem frame_derived
    (rs_used rs_frame : List Resource)
    (ρ : Valuation)
    (h_used h_frame : HeapFragment)
    -- Frame is disjoint from used resources
    (hDisj : h_used.disjoint h_frame)
    -- Used resources satisfy their interpretation
    (hUsedSat : interpResources rs_used ρ h_used)
    -- Frame resources satisfy their interpretation
    (hFrameSat : interpResources rs_frame ρ h_frame)
    : interpResources (rs_used ++ rs_frame) ρ (h_used ++ h_frame) := by
  -- Proof generated by Aristotle (project: cf869c1a-b686-4f52-8389-f70b841a907c)
  induction' rs_used with r rs ih generalizing h_used h_frame ρ;
  · cases hUsedSat ; aesop;
  · obtain ⟨ h1, h2, h_disjoint, h_eq, h_r, h_rs ⟩ := hUsedSat;
    rw [h_eq];
    refine' ⟨ h1, h2 ++ h_frame, _, _, h_r, _ ⟩;
    · intro loc hloc hloc'; simp_all +decide [ CerbLean.CN.Semantics.HeapFragment.disjoint ] ;
      simp_all +decide [ HeapFragment.dom ];
      contrapose! hDisj;
      obtain ⟨ x, hx ⟩ := hloc
      obtain ⟨ y, hy ⟩ := hloc'
      use loc, x, by
        exact List.mem_append_left _ hx, y, by
        exact List.mem_append.mp hy |> Or.resolve_left <| by aesop;
    · have h_assoc : ∀ (h1 h2 h3 : HeapFragment), (h1 ++ h2) ++ h3 = h1 ++ (h2 ++ h3) := by
        intros h1 h2 h3; exact (by
        exact congr_arg _ ( List.append_assoc _ _ _ ));
      exact h_assoc _ _ _;
    · exact ih ρ h2 h_frame ( by
        intro loc hloc1 hloc2; exact hDisj loc ( by
          simp_all +decide [ HeapFragment.dom ];
          exact ⟨ hloc1.choose, List.mem_append_right _ hloc1.choose_spec ⟩ ) hloc2; ) h_rs hFrameSat

end CerbLean.CN.Semantics
